<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="dns-prefetch" href="http://xieyuxuan.cc">
  <title>谢雨轩的博客 | Vera Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前端技术分享,前端个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="谢雨轩的博客 | Vera Blog">
<meta property="og:url" content="http://xieyuxuan.cc/page/3/index.html">
<meta property="og:site_name" content="谢雨轩的博客 | Vera Blog">
<meta property="og:description" content="前端技术分享,前端个人博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="谢雨轩的博客 | Vera Blog">
<meta name="twitter:description" content="前端技术分享,前端个人博客">
  
    <link rel="alternative" href="/atom.xml" title="谢雨轩的博客 | Vera Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/favicon.png">
  
  <link rel="stylesheet" href="/main.css">
  



  <!-- Piwik -->
  <script type="text/javascript">
    var _paq = _paq || [];
    // tracker methods like "setCustomDimension" should be called before "trackPageView"
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
      var u="//piwik.mritd.me/";
      _paq.push(['setTrackerUrl', u+'piwik.php']);
      _paq.push(['setSiteId', '3']);
      var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
      g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'piwik.js'; s.parentNode.insertBefore(g,s);
    })();
  </script>
  <!-- End Piwik Code -->
</head>
</html>
<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/images/userimg.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">谢雨轩</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Web前端技术宅升级打倒小怪兽</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/types/webpack.html">webpack教程</a></li>
	        
				<li><a href="/types/origincode.html">源码剖析</a></li>
	        
				<li><a href="/types/web.html">移动端直通车</a></li>
	        
				<li><a href="/types/script.html">神奇JS</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">我的项目</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/Vera0707/huanhuashuixie" title="github">github</a>
		        
					<a class="mail" target="_blank" href="/lishuxia@gozap.com" title="mail">mail</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">谢雨轩</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/images/userimg.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">谢雨轩</h1>
			</hgroup>
			
			<p class="header-subtitle">Web前端技术宅升级打倒小怪兽</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/types/webpack.html">webpack教程</a></li>
		        
					<li><a href="/types/origincode.html">源码剖析</a></li>
		        
					<li><a href="/types/web.html">移动端直通车</a></li>
		        
					<li><a href="/types/script.html">神奇JS</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Vera0707/huanhuashuixie" title="github">github</a>
			        
						<a class="mail" target="_blank" href="/lishuxia@gozap.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <canvas id="body-wrap"> </canvas>
      <div class="body-wrap">
          
  
    <article id="post-designPatternsSRP" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/29/designPatternsSRP/">前端设计模式之单一职责原则(SRP)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h6 id="译注：本文作者愤怒的韭菜"><a href="#译注：本文作者愤怒的韭菜" class="headerlink" title="译注：本文作者愤怒的韭菜"></a>译注：本文作者<a href="https://blog.csdn.net/zhengzhb/article/details/7278174" target="_blank" rel="noopener">愤怒的韭菜</a></h6><p>&emsp;&emsp;<abbr style="font-weight:bold;">定义:</abbr><br>&emsp;&emsp;不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。</p>
<p>&emsp;&emsp;<abbr style="font-weight:bold;">问题由来:</abbr><br>&emsp;&emsp;类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。</p>
<p>&emsp;&emsp;<abbr style="font-weight:bold;">解决方案:</abbr><br>&emsp;&emsp;遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。</p>
<p>&emsp;&emsp;说到单一职责原则，很多人都会不屑一顾。因为它太简单了。稍有经验的程序员即使从来没有读过设计模式、从来没有听说过单一职责原则，在设计软件时也会自觉的遵守这一重要原则，因为这是常识。在软件编程中，谁也不希望因为修改了一个功能导致其他的功能发生故障。而避免出现这一问题的方法便是遵循单一职责原则。虽然单一职责原则如此简单，并且被认为是常识，但是即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。为什么会出现这种现象呢？因为有职责扩散。所谓职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2。</p>
<p>&emsp;&emsp;比如：类T只负责一个职责P，这样设计是符合单一职责原则的。后来由于某种原因，也许是需求变更了，也许是程序的设计者境界提高了，需要将职责P细分为粒度更细的职责P1，P2，这时如果要使程序遵循单一职责原则，需要将类T也分解为两个类T1和T2，分别负责P1、P2两个职责。但是在程序已经写好的情况下，这样做简直太费时间了。所以，简单的修改类T，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。（这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责P，在未来可能会扩散为P1，P2，P3，P4……Pn。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。）</p>
<p>&emsp;&emsp;举例说明，用一个类描述动物呼吸这个场景：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">    public void breathe(String animal)&#123;</span><br><span class="line">        System.out.println(animal+&quot;呼吸空气&quot;);</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line">    public class Client&#123;</span><br><span class="line">        public static void main(String[] args)&#123;</span><br><span class="line">            Animal animal = new Animal();</span><br><span class="line">            animal.breathe(&quot;牛&quot;);</span><br><span class="line">            animal.breathe(&quot;羊&quot;);</span><br><span class="line">            animal.breathe(&quot;猪&quot;);</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">牛呼吸空气</span><br><span class="line">羊呼吸空气</span><br><span class="line">猪呼吸空气</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将Animal类细分为陆生动物类Terrestrial，水生动物Aquatic，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Terrestrial&#123;</span><br><span class="line">     public void breathe(String animal)&#123;</span><br><span class="line">          System.out.println(animal+&quot;呼吸空气&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Aquatic&#123;</span><br><span class="line">     public void breathe(String animal)&#123;</span><br><span class="line">           System.out.println(animal+&quot;呼吸水&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client&#123;</span><br><span class="line">     public static void main(String[] args)&#123;</span><br><span class="line">         Terrestrial terrestrial = new Terrestrial();</span><br><span class="line">         terrestrial.breathe(&quot;牛&quot;);</span><br><span class="line">         terrestrial.breathe(&quot;羊&quot;);</span><br><span class="line">         terrestrial.breathe(&quot;猪&quot;);</span><br><span class="line">         Aquatic aquatic = new Aquatic();</span><br><span class="line">         aquatic.breathe(&quot;鱼&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">牛呼吸空气</span><br><span class="line">羊呼吸空气</span><br><span class="line">猪呼吸空气</span><br><span class="line">鱼呼吸水</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类Animal来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">    public void breathe(String animal)&#123;</span><br><span class="line">        if(&quot;鱼&quot;.equals(animal))&#123;</span><br><span class="line">            System.out.println(animal+&quot;呼吸水&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(animal+&quot;呼吸空气&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Client&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Animal animal = new Animal();</span><br><span class="line">        animal.breathe(&quot;牛&quot;);</span><br><span class="line">        animal.breathe(&quot;羊&quot;);</span><br><span class="line">        animal.breathe(&quot;猪&quot;);</span><br><span class="line">        animal.breathe(&quot;鱼&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到，这种修改方式要简单的多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改Animal类的breathe方法，而对原有代码的修改会对调用“猪”“牛”“羊”等相关功能带来风险，也许某一天你会发现程序运行的结果变为“牛呼吸水”了。这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">     public void breathe(String animal)&#123;</span><br><span class="line">         System.out.println(animal+&quot;呼吸空气&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     public void breathe2(String animal)&#123;</span><br><span class="line">         System.out.println(animal+&quot;呼吸水&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client&#123;</span><br><span class="line">     public static void main(String[] args)&#123;</span><br><span class="line">         Animal animal = new Animal();</span><br><span class="line">         animal.breathe(&quot;牛&quot;);</span><br><span class="line">         animal.breathe(&quot;羊&quot;);</span><br><span class="line">         animal.breathe(&quot;猪&quot;);</span><br><span class="line">         animal.breathe2(&quot;鱼&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一中呢？其实这真的比较难说，需要根据实际情况来确定。我的原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则；</p>
<p>&emsp;&emsp;例如本文所举的这个例子，它太简单了，它只有一个方法，所以，无论是在代码级别上违反单一职责原则，还是在方法级别上违反，都不会造成太大的影响。实际应用中的类都要复杂的多，一旦发生职责扩散而需要修改类时，除非这个类本身非常简单，否则还是遵循单一职责原则的好。</p>
<p>&emsp;&emsp;遵循单一职责原的优点有：</p>
<p>&emsp;&emsp;&gt; 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；<br>&emsp;&emsp;&gt; 提高类的可读性，提高系统的可维护性；<br>&emsp;&emsp;&gt; 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</p>
<p>&emsp;&emsp;需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。</p>

      
    </div>
      <div id="remark"></div>
    <div class="article-info article-info-index">
      
      <a href="/2018/09/29/designPatternsSRP/" class="archive-article-date">
  	<time datetime="2018-09-29T06:46:46.000Z" itemprop="datePublished"><i class="icon-clock"></i>2018-09-29</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端设计模式/">前端设计模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单一职责原则/">单一职责原则</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/个人博客/">个人博客</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-vim" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/23/vim/">Vim入门基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<p>@(welcome)[前端菜鸟|掘金中]</p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>&emsp;&emsp;Vim（Vi[Improved]）编辑器是功能强大的跨平台文本文件编辑工具，继承自Unix系统的Vi编辑器，支持Linux/Mac OS X/Windows系统，利用它可以建立、修改文本文件。进入Vim编辑程序，可以在终端输入下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$vim [filename]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中<code>filename</code>是要编辑器的文件的路径名。如果文件不存在，它将为你建立一个新文件。Vim编辑程序有三种操作模式，分别称为 编辑模式、插入模式 和 命令模式，当运行Vim时，首先进入编辑模式。</p>
<h2 id="2-编辑模式"><a href="#2-编辑模式" class="headerlink" title="2. 编辑模式"></a>2. 编辑模式</h2><p>&emsp;&emsp;Vim编辑方式的主要用途是在被编辑的文件中移动光标的位置。一旦光标移到到所要的位置，就可以进行剪切和粘贴正文块，删除正文和插入新的正文。当完成所有的编辑工作后，需要保存编辑器结果，退出编辑程序回到终端，可以发出<code>ZZ</code>命令，连续按两次大写的<code>Z</code>键。</p>
<h3 id="2-1-跳转"><a href="#2-1-跳转" class="headerlink" title="2.1 跳转"></a>2.1 跳转</h3><p>&emsp;&emsp;如果键盘上有上、下、左、右箭头的导航键，就由这些键来完成光标的移动。另外，可以用下面的键完成同样的 按字符移动 功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k               上移；</span><br><span class="line">j               下移；</span><br><span class="line">h               左移；</span><br><span class="line">l               右移。</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面这４个键将光标位置每次移动一行或一个 字符 。Vim还提供稍大范围移动光标的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctrl+f      在文件中前移一页（相当于 page down）；</span><br><span class="line">ctrl+b      在文件中后移一页（相当于 page up）；</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;更大范围的移动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*         当光标停留在一个单词上，* 键会在文件内搜索该单词，并跳转到下一处；</span><br><span class="line">#         当光标停留在一个单词上，# 在文件内搜索该单词，并跳转到上一处；</span><br><span class="line">(/)       移动到 前/后 句 的开始；</span><br><span class="line">&#123;/&#125;       跳转到 当前/下一个 段落 的开始。</span><br><span class="line">g_        到本行最后一个不是 blank 字符的位置。</span><br><span class="line">fa        到下一个为 a 的字符处，你也可以fs到下一个为s的字符。</span><br><span class="line">t,        到逗号前的第一个字符。逗号可以变成其它字符。</span><br><span class="line">3fa       在当前行查找第三个出现的 a。</span><br><span class="line">F/T       和 f 和 t 一样，只不过是相反方向;</span><br><span class="line">gg        将光标定位到文件第一行起始位置；</span><br><span class="line">G         将光标定位到文件最后一行起始位置；</span><br><span class="line">NG或Ngg   将光标定位到第 N 行的起始位置。</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在屏幕中找到需要的 一页 时，可以用下面的命令快速移动光标：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">H               将光标移到屏幕上的起始行（或最上行）；</span><br><span class="line">M               将光标移到屏幕中间；</span><br><span class="line">L               将光标移到屏幕最后一行。</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;同样需要注意字母的大小写。<code>H</code>和 <code>L</code>命令还可以加数字。如<code>2H</code>表示将光标移到屏幕的第２行，<code>3L</code>表示将光标移到屏幕的倒数第3行。</p>
<p>&emsp;&emsp;当将光标移到所要的行是，行内移动 光标可以用下面的命令来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">w               右移光标到下一个字的开头；</span><br><span class="line">e               右移光标到一个字的末尾；</span><br><span class="line">b               左移光标到前一个字的开头；</span><br><span class="line">0               数字０，左移光标到本行的开始；</span><br><span class="line">$               右移光标，到本行的末尾；</span><br><span class="line">^               移动光标，到本行的第一个非空字符。</span><br></pre></td></tr></table></figure>
<h3 id="2-2-搜索匹配"><a href="#2-2-搜索匹配" class="headerlink" title="2.2 搜索匹配"></a>2.2 搜索匹配</h3><p>&emsp;&emsp;和许多先进的编辑器一样，Vim 提供了强大的字符串搜索功能。要查找文件中指定字或短语出现的位置，可以用Vim直接进行搜索，而不必以手工方式进行。搜索方法是：键入字符<code>/</code>，后面跟以要搜索的字符串，然后按回车键。编辑程序执行正向搜索（即朝文件末尾方向），并在找到指定字符串后，将光标停到该字符串的开头；键入<code>n</code>命令可以继续执行搜索，找出这一字符串下次出现的位置。用字符<code>?</code>取代<code>/</code>，可以实现反向搜索（朝文件开头方向）。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/str1               正向搜索字符串 str1；</span><br><span class="line">n                   继续搜索，找出 str1 字符串下次出现的位置；</span><br><span class="line">N                   继续搜索，找出 str1 字符串上一次出现的位置；</span><br><span class="line">?str2               反向搜索字符串 str2 。</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;无论搜索方向如何，当到达文件末尾或开头时，搜索工作会循环到文件的另一端并继续执行。<br>Vim中执行搜索匹配最强大的地方是结合 <abbr style="font-weight:bold"> 正则表达式 </abbr> 来搜索，后续将会介绍。</p>
<h3 id="2-3-替换和删除"><a href="#2-3-替换和删除" class="headerlink" title="2.3 替换和删除"></a>2.3 替换和删除</h3><p>&emsp;&emsp;Vim常规的删除命令是 <code>d</code>、<code>x</code>(前者删除 <code>行</code>，后者删除<code>字符</code> ),结合Vim的其他特性可以实现基础的删除功能。将光标定位于文件内指定位置后，可以用其他字符来替换光标所指向的字符，或从当前光标位置删除一个或多个字符或一行、多行。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rc                用 c 替换光标所指向的当前字符；</span><br><span class="line">nrc               用 c 替换光标所指向的前 n 个字符；</span><br><span class="line">5rA               用 A 替换光标所指向的前 5 个字符；</span><br><span class="line">x                 删除光标所指向的当前字符；</span><br><span class="line">nx                删除光标所指向的前 n 个字符；</span><br><span class="line">3x                删除光标所指向的前 3 个字符；</span><br><span class="line">dw                删除光标右侧的字；</span><br><span class="line">ndw               删除光标右侧的 n 个字；</span><br><span class="line">3dw               删除光标右侧的 3 个字；</span><br><span class="line">db                删除光标左侧的字；</span><br><span class="line">ndb               删除光标左侧的 n 个字；</span><br><span class="line">5db               删除光标左侧的 5 个字；</span><br><span class="line">dd                删除光标所在行，并去除空隙；</span><br><span class="line">ndd               删除（剪切） n 行内容，并去除空隙；</span><br><span class="line">3dd               删除（剪切） 3 行内容，并去除空隙；</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其他常用的删除命令有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d$              从当前光标起删除字符直到行的结束；</span><br><span class="line">d0              从当前光标起删除字符直到行的开始；</span><br><span class="line">J                删除本行的回车符（CR），并和下一行合并。</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Vim常规的替换命令有<code>c</code>和<code>s</code>，结合Vim的其他特性可以实现基础的替换功能，不过替换命令执行以后，通常会由<abbr style="font-weight:bold"> 编辑模式 </abbr>进入<abbr style="font-weight:bold"> 插入模式 </abbr>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s              用输入的正文替换光标所指向的字符；</span><br><span class="line">S              删除当前行，并进入插入模式；</span><br><span class="line">ns             用输入的正文替换光标右侧 n 个字符；</span><br><span class="line">nS             删除当前行在内的 n 行，并进入插入模式；</span><br><span class="line">cw             用输入的正文替换光标右侧的字；</span><br><span class="line">cW             用输入的正文替换从光标到行尾的所有字符（同 c$ )；</span><br><span class="line">ncw            用输入的正文替换光标右侧的 n 个字；</span><br><span class="line">cb             用输入的正文替换光标左侧的字；</span><br><span class="line">ncb            用输入的正文替换光标左侧的 n 个字；</span><br><span class="line">cd             用输入的正文替换光标的所在行；</span><br><span class="line">ncd            用输入的正文替换光标下面的 n 行；</span><br><span class="line">c$             用输入的正文替换从光标开始到本行末尾的所有字符；</span><br><span class="line">c0             用输入的正文替换从本行开头到光标的所有字符。</span><br></pre></td></tr></table></figure>
<h3 id="2-4-复制粘贴"><a href="#2-4-复制粘贴" class="headerlink" title="2.4 复制粘贴"></a>2.4 复制粘贴</h3><p>&emsp;&emsp;从正文中删除的内容（如字符、字或行）并没有真正丢失，而是被剪切并复制到了一个内存缓冲区中。用户可将其粘贴到正文中的指定位置。完成这一操作的命令是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p               小写字母 p，将缓冲区的内容粘贴到光标的后面；</span><br><span class="line">P               大写字母 P，将缓冲区的内容粘贴到光标的前面。</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果缓冲区的内容是字符或字，直接粘贴在光标的前面或后面；如果缓冲区的内容为整行正文，执行上述粘贴命令将会粘贴在当前光标所在行的上一行或下一行。</p>
<p>&emsp;&emsp;注意上述两个命令中字母的大小写。Vim 编辑器经常以一对大、小写字母（如<code>p</code>和<code>P</code>）来提供一对相似的功能。通常，小写命令在光标的后面进行操作，大写命令在光标的前面进行操作。</p>
<p>&emsp;&emsp;有时需要复制一段正文到新位置，同时保留原有位置的内容。这种情况下，首先应当把指定内容复制（而不是剪切）到内存缓冲区。完成这一操作的命令是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yy              复制当前行到内存缓冲区；</span><br><span class="line">nyy             复制 n 行内容到内存缓冲区；</span><br><span class="line">5yy             复制 5 行内容到内存缓冲区；</span><br><span class="line">“+y             复制 1 行到操作系统的粘贴板；</span><br><span class="line">“+nyy           复制 n 行到操作系统的粘贴板。</span><br></pre></td></tr></table></figure>
<h3 id="2-5-撤销和重复"><a href="#2-5-撤销和重复" class="headerlink" title="2.5 撤销和重复"></a>2.5 撤销和重复</h3><p>&emsp;&emsp;在编辑文档的过程中，为消除某个错误的编辑命令造成的后果，可以用撤消命令。另外，如果用户希望在新的光标位置重复前面执行过的编辑命令，可用重复命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u               撤消前一条命令的结果；</span><br><span class="line">.              重复最后一条修改正文的命令。</span><br></pre></td></tr></table></figure>
<h2 id="3-插入模式"><a href="#3-插入模式" class="headerlink" title="3. 插入模式"></a>3. 插入模式</h2><h3 id="3-1-进入插入模式"><a href="#3-1-进入插入模式" class="headerlink" title="3.1 进入插入模式"></a>3.1 进入插入模式</h3><p>&emsp;&emsp;在编辑模式下正确定位光标之后，可用以下命令切换到插入模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i            在光标左侧插入正文</span><br><span class="line">a            在光标右侧插入正文</span><br><span class="line">o            在光标所在行的下一行增添新行</span><br><span class="line">O            在光标所在行的上一行增添新行</span><br><span class="line">I            在光标所在行的开头插入</span><br><span class="line">A            在光标所在行的末尾插入</span><br></pre></td></tr></table></figure>
<h3 id="3-2-退出插入模式"><a href="#3-2-退出插入模式" class="headerlink" title="3.2 退出插入模式"></a>3.2 退出插入模式</h3><p>&emsp;&emsp;退出插入模式的方法是，按 <code>ESC</code> 键或组合键 <code>Ctrl+[</code> ，退出插入模式之后，将会进入编辑模式 。</p>
<h2 id="4-命令模式"><a href="#4-命令模式" class="headerlink" title="4. 命令模式"></a>4. 命令模式</h2><p>&emsp;&emsp;在已经启动的Vim中打开一个文件需要用 <code>:e</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:e path_to_file/filename</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;保存当前编辑的文件需要用 <code>:w</code>命令（单词 <code>write</code> 的缩写）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将当前文件另存为 <code>file_temp</code> 则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w file_temp</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在编辑模式下可以用 <code>ZZ</code> 命令退出Vim编辑程序，该命令保存对正文所作的修改，覆盖原始文件。如果只需要退出编辑程序，而不打算保存编辑的内容，可用下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">: q             在未作修改的情况下退出；</span><br><span class="line">: q!            放弃所有修改，退出编辑程序。</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;保存并退出则可以讲两条命令结合起来使用（注意命令顺序，先保存，后退出）：</p>
<h3 id="4-2-行号与文件"><a href="#4-2-行号与文件" class="headerlink" title="4.2  行号与文件"></a>4.2  行号与文件</h3><p>&emsp;&emsp;编辑中的每一行正文都有自己的行号，用下列命令可以移动光标到指定行（效果与 编辑模式 下的 <code>ngg</code> 或 <code>nG</code> 相同）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: n             将光标移到第 n 行</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;命令模式下，可以规定命令操作的行号范围。数值用来指定绝对行号；字符“.”表示光标所在行的行号；字符符“$”表示正文最后一行的行号；简单的表达式，例如“.+5”表示当前行往下的第 5 行。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:345                  将光标移到第 345 行</span><br><span class="line">:345w file            将第 345 行写入 file 文件</span><br><span class="line">:3,5w file            将第 3 行至第 5 行写入 file 文件</span><br><span class="line">:1,.w file            将第 1 行至当前行写入 file 文件</span><br><span class="line">:.,$w file            将当前行至最后一行写入 file 文件</span><br><span class="line">:.,.+5w file          从当前行开始将 6 行内容写入 file 文件</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在命令模式下，允许从文件中读取正文，或将正文写入文件。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:w                 将编辑的内容写入原始文件，用来保存编辑的中间结果</span><br><span class="line">:wq                将编辑的内容写入原始文件并退出编辑程序（相当于 ZZ 命令）</span><br><span class="line">:w file            将编辑的内容写入 file 文件，保持原有文件的内容不变</span><br><span class="line">:a,bw file         将第 a 行至第 b 行的内容写入 file 文件</span><br><span class="line">:r file            读取 file 文件的内容，插入当前光标所在行的后面</span><br><span class="line">:e file            编辑新文件 file 代替原有内容</span><br><span class="line">:f file            将当前文件重命名为 file</span><br><span class="line">:f                 打印当前文件名称和状态，如文件的行数、光标所在的行号等</span><br></pre></td></tr></table></figure>
<h3 id="4-3-字符串搜索"><a href="#4-3-字符串搜索" class="headerlink" title="4.3  字符串搜索"></a>4.3  字符串搜索</h3><p>&emsp;&emsp;在 <abbr style="font-weight:bold"> 编辑模式  </abbr>讲过字符串的搜索，此处的<abbr style="font-weight:bold"> 命令模式  </abbr>也可以进行字符串搜索，给出一个字符串，可以通过搜索该字符串到达指定行。如果希望进行正向搜索，将待搜索的字符串置于两个<code>/</code>之间；如果希望反向搜索，则将字符串放在两个<code>?</code>之间。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:/str/                  正向搜索，将光标移到下一个包含字符串 str 的行</span><br><span class="line">:?str?                  反向搜索，将光标移到上一个包含字符串 str 的行</span><br><span class="line">:/str/w file            正向搜索，并将第一个包含字符串 str 的行写入 file 文件</span><br><span class="line">:/str1/,/str2/w file    正向搜索，并将包含字符串 str1 的行至包含字符串 str2 的行写</span><br></pre></td></tr></table></figure>
<h3 id="4-4-字符串搜索"><a href="#4-4-字符串搜索" class="headerlink" title="4.4  字符串搜索"></a>4.4  字符串搜索</h3><p>&emsp;&emsp;当给Vim指定搜索字符串时，可以包含具有特殊含义的字符。包含这些特殊字符的搜索字符串称为正则表达式（Regular Expressions）。例如，要搜索一行正文，这行正文的开头包含 <code>struct</code> 字。下面的命令做不到这一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:/struct/</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;因为它只找出在行中任意位置包含<code>struct</code>的第一行，并不一定在行的开始包含<code>struct</code>。解决问题的办法是在搜索字符串前面加上特殊字符^：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:/^struct/</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>^</code>字符比较每行开头的字符串。所以上面的命令表示：找出以字符串<code>struct</code>开头的行。</p>
<p>&emsp;&emsp;也可以用类似办法在搜索字符串后面加上表示行的末尾的特殊字符 $ 来找出位于行末尾的字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:/^struct/</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;下表给出大多数特殊字符和它们的含义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">^               放在字符串前面，匹配行首的字；</span><br><span class="line">$               放在字符串后面，匹配行尾的字；</span><br><span class="line">\&lt;              匹配一个字的字头；</span><br><span class="line">\&gt;              匹配一个字的字尾；</span><br><span class="line">.               匹配任何单个正文字符；</span><br><span class="line">[str]           匹配 str 中的任何单个字符；</span><br><span class="line">[^str]          匹配任何不在 str 中的单个字符；</span><br><span class="line">[a-b]           匹配 a 到 b 之间的任一字符；</span><br><span class="line">*               匹配前一个字符的 0 次或多次出现；</span><br><span class="line">\               转义后面的字符。</span><br></pre></td></tr></table></figure>
<h3 id="4-5-正文替换"><a href="#4-5-正文替换" class="headerlink" title="4.5  正文替换"></a>4.5  正文替换</h3><p>&emsp;&emsp;利用<code>:s</code>命令可以实现字符串的替换。具体的用法包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:%s/str1/str2/      用字符串 str2 替换行中首次出现的字符串 str1</span><br><span class="line">:s/str1/str2/g      用字符串 str2 替换行中所有出现的字符串 str1</span><br><span class="line">:.,$ s/str1/str2/g  用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1</span><br><span class="line">:1,$ s/str1/str2/g  用字符串 str2 替换正文中所有出现的字符串 str1</span><br><span class="line">:g/str1/s//str2/g    功能同上</span><br><span class="line">:m,ns/str1/str2/g    将从m行到n行的str1替换成str2</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从上述替换命令可以看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`g` 放在命令末尾，表示对搜索字符串的每次出现进行替换,不止匹配每行中的第一次出现；不加 `g`，表示只对搜索字符串的首次出现进行替换；`g` 放在命令开头，表示对正文中所有包含搜索字符串的行进行替换操作;</span><br><span class="line">`s` 表示后面跟着一串替换的命令；</span><br><span class="line">`%` 表示替换范围是所有行，即全文。</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;另外一个实用的命令，在Vim中统计当前文件中字符串 <code>str1</code> 出现的次数，可用替换命令的变形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/str1/&amp;/gn</span><br></pre></td></tr></table></figure>
<h3 id="4-6-删除正文"><a href="#4-6-删除正文" class="headerlink" title="4.6  删除正文"></a>4.6  删除正文</h3><p>&emsp;&emsp;在命令模式下，同样可以删除正文中的内容。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:d                              删除光标所在行</span><br><span class="line">:3d                             删除 3 行</span><br><span class="line">:.,$d                           删除当前行至正文的末尾</span><br><span class="line">:/str1/,/str2/d                 删除从字符串 str1 到 str2 的所有行</span><br><span class="line">:g/^\(.*\)$\n\1$/d              删除连续相同的行，保留最后一行</span><br><span class="line">:g/\%(^\1$\n\)\@&lt;=\(.*\)$/d     删除连续相同的行，保留最开始一行</span><br><span class="line">:g/^\s*$\n\s*$/d                删除连续多个空行，只保留一行空行</span><br><span class="line">:5,20s/^#//g                    删除5到20行开头的 # 注释</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;总之，Vim的初级删除命令是用 <code>d</code> ，高级删除命令可以用<abbr style="font-weight:bold"> 正则替换  </abbr></p>
<h3 id="4-7-恢复文件"><a href="#4-7-恢复文件" class="headerlink" title="4.7  恢复文件"></a>4.7  恢复文件</h3><p>&emsp;&emsp;Vim 在编辑某个文件时，会另外生成一个临时文件，这个文件的名称通常以<code>.</code>开头，并以<code>.swp</code>结尾。Vim 在正常退出时，该文件被删除，若意外退出，而没有保存文件的最新修改内容，则可以使用恢复命令<code>:recover</code>来恢复文件，也可以在启动Vim时用<code>-r</code>选项。</p>
<h3 id="4-8-选项设置"><a href="#4-8-选项设置" class="headerlink" title="4.8  选项设置"></a>4.8  选项设置</h3><p>&emsp;&emsp;为控制不同的编辑功能，Vim 提供了很多内部选项。利用 :set 命令可以设置选项。基本语法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set option         设置选项 option</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;常见的功能选项包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">autoindent      设置该选项，则正文自动缩进</span><br><span class="line">ignorecase      设置该选项，则忽略规则表达式中大小写字母的区别</span><br><span class="line">number          设置该选项，则显示正文行号</span><br><span class="line">ruler           设置该选项，则在屏幕底部显示光标所在行、列的位置</span><br><span class="line">tabstop         设置按 Tab 键跳过的空格数。例如 :set tabstop=n，n 默认值为 8</span><br><span class="line">mk              将选项保存在当前目录的 .exrc 文件中</span><br></pre></td></tr></table></figure>
<h3 id="4-9-Shell切换"><a href="#4-9-Shell切换" class="headerlink" title="4.9  Shell切换"></a>4.9  Shell切换</h3><p>&emsp;&emsp;当处于编辑的对话过程中时，可能需要执行一些Linux命令。如果需要保存当前的结果，退出编辑程序，再执行所需的Linux命令，然后再回头继续编辑过程，就显得十分累赘。如果能在编辑的环境中运行Linux命令就要省事得多。在Vim中，可以用下面的命令来做到这一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!shell_command   执行完 shell_command 后回到Vim</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这称为Shell切换。它允许执行任何可以在标准的Shell提示符下执行的命令。当这条命令执行完毕，控制返回给编辑程序。又可以继续编辑对话过程。</p>
<h3 id="4-10-分屏与标签页"><a href="#4-10-分屏与标签页" class="headerlink" title="4.10  分屏与标签页"></a>4.10  分屏与标签页</h3><h4 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h4><p>&emsp;&emsp;普通的Vim模式，打开一个Vim程序只能查看一个文件，如果想同时查看多个文件，就需要用到Vim分屏与标签页功能。</p>
<p>&emsp;&emsp;Vim的分屏，主要有两种方式：上下分屏（水平分屏）和左右分屏（垂直分屏），在命令模式分别敲入以下命令即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:split（可用缩写 :sp）            上下分屏；</span><br><span class="line">:vsplit（可用缩写 :vsp）          左右分屏。</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;另外，也可以在终端里启动vim时就开启分屏操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim -On file1 file2...   打开 file1 和 file2 ，垂直分屏</span><br><span class="line">vim -on file1 file2...   打开 file1 和 file2 ，水平分屏</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;理论上，一个Vim窗口，可以分为多个Vim屏幕，切换屏幕需要用键盘快捷键，命令分别有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+w+h            切换到当前分屏的左边一屏；</span><br><span class="line">Ctrl+w+l            切换到当前分屏的右边一屏；</span><br><span class="line">Ctrl+w+j            切换到当前分屏的下方一屏；</span><br><span class="line">Ctrl+w+k            切换到当前分屏的上方一屏。</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;即键盘上的<code>h,j,k,l</code> 四个Vim专用方向键，配合<code>Ctrl</code>键和<code>w</code>键（<code>window</code>的缩写），就能跳转到目标分屏。另外，也可以直接按 <code>Ctrl+w+w</code>来跳转分屏，不过跳转方向则是在当前Vim窗口所有分屏中，按照逆时针方向跳转。<br>&emsp;&emsp;下面是改变尺寸的一些操作，主要是高度，对于宽度你可以使用 <code>[Ctrl+W &lt;]</code> 或是 <code>[Ctrl+W &gt;]</code> ，但这可能需要最新的版本才支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+W =            让所有的屏都有一样的高度；</span><br><span class="line">Ctrl+W +            增加高度；</span><br><span class="line">Ctrl+W -            减少高度。</span><br></pre></td></tr></table></figure>
<h4 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h4><p>&emsp;&emsp;Vim的标签（Tab）页，类似浏览器的标签页，一个标签页打开一个Vim的窗口，一个Vim的窗口可以支持N个分屏。</p>
<p>&emsp;&emsp;在Vim中新建一个标签的命令是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:tabnew</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果要在新建标签页的同时打开一个文件，则可以在命令后面直接附带文件路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:tabnew filename</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Vim中的每个标签页有一个唯一的数字序号，第一个标签页的序号是<code>0</code>，从左向右依次加一。关于标签页有一系列操作命令，简介如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">:tN[ext]                跳转到上一个匹配的标签</span><br><span class="line">:tabN[ext]              跳到上一个标签页</span><br><span class="line">:tabc[lose]             关闭当前标签页</span><br><span class="line">:tabdo                  为每个标签页执行命令</span><br><span class="line">:tabe[dit]              在新标签页里编辑文件</span><br><span class="line">:tabf[ind]              寻找 &apos;path&apos; 里的文件，在新标签页里编辑之</span><br><span class="line">:tabfir[st]             转到第一个标签页</span><br><span class="line">:tabl[ast]              转到最后一个标签页</span><br><span class="line">:tabm[ove]  N           把标签页移到序号为N位置</span><br><span class="line">:tabnew [filename]      在新标签页里编辑文件</span><br><span class="line">:tabn[ext]              转到下一个标签页</span><br><span class="line">:tabo[nly]              关闭所有除了当前标签页以外的所有标签页</span><br><span class="line">:tabp[revious]          转到前一个标签页</span><br><span class="line">:tabr[ewind]            转到第一个标签页</span><br></pre></td></tr></table></figure>
<h3 id="4-11-与外部工具集成"><a href="#4-11-与外部工具集成" class="headerlink" title="4.11  与外部工具集成"></a>4.11  与外部工具集成</h3><p>&emsp;&emsp;Vim可以与许多外部程序集成，功能十分强大，比如 diff , ctags , sort , xxd 等等，下面选取几个简单介绍一下。</p>
<h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p>&emsp;&emsp;Linux命令<code>diff</code>用来对比两个文件的内容，不过对比结果显示在终端里，可读性比较差。结合Vim，在终端里可以直接输入命令<code>vimdiff</code>，后面跟两个文件名作为参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimdiff file1 file2</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;即可在Vim里分屏显示两个文件内容的对比结果，对文件内容差异部分进行高亮标记，还可以同步滚动两个文件内容，更可以实时修改文件内容，方便程度和用户体验大大提高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimdiff a.txt b.txt</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果直接给 <code>-d</code>选项是一样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -d a.txt b.txt</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;除了在终端里开启vimdiff 功能，也可以在打开Vim后，在Vim的命令模式输入相关命令来开启 <code>vimdiff</code> 功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:diffsplit abc.txt</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果你现在已经开启了一个文件，想Vim帮你区分你的文件跟 <code>abc.txt</code> 有什么区别，可以在Vim中用 <code>diffsplit</code> 的方式打开第二个文件，这个时 候Vim会用 <code>split</code>（分上下两屏）的方式开启第二个文件，并且通过颜色，<code>fold</code> 来显示两个文件的区别<br>&emsp;&emsp;这样Vim就会用颜色帮你区分开2个文件的区别。如果文件比较大（源码）重复的部分会帮你折叠起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:diffpatch filename</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过 <code>:diffpatch</code>你的patch的文件名，就可以以当前文件加上你的patch来显示。vim会split一个新的屏，显示patch后的信息并且用颜色标明区别。<br>&emsp;&emsp;如果不喜欢上下对比，喜欢左右（比较符合视觉）可以在前面加 <code>vert</code> ，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:vert diffsplit abc.txt</span><br><span class="line">:vert diffpatch abc.txt</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;看完diff，用<code>:only</code> 回到原本编辑的文件，觉得diff的讨厌颜色还是在哪里，只要用<code>:diffoff</code> 关闭就好了。<br>&emsp;&emsp;还有个常用的diff中的就是 <code>:diffu</code>,这个是 <code>:diffupdate</code> 的简写，更新的时候用。</p>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>&emsp;&emsp;Linux命令 <code>sort</code> 可以对文本内容进行按行中的字符比较、排序，但在终端里使用 <code>sort</code> 命令处理文件，并不能实时查看文件内容。具体用法请自查手册。</p>
<h4 id="xxd"><a href="#xxd" class="headerlink" title="xxd"></a>xxd</h4><p>&emsp;&emsp;<code>vim+xxd</code> 是Linux下最常用的二进制文本编辑工具，<code>xxd</code>其实是Vim外部的一个转换程序，随Vim一起发布，在Vim里调用它来编辑二进制文本非常方便。<br>&emsp;&emsp;首先以二进制模式在终端里打开一个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -b filename</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Vim 的 <code>-b</code> 选项是告诉 Vim 打开的是一个二进制文件，不指定的话，会在后面加上 <code>0x0a</code> ，即一个换行符。<br>&emsp;&emsp;然后在Vim的命令模式下键入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%!xxd</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;即可看到二进制模式显示出来的文本，看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000: 1f8b 0808 39d7 173b 0203 7474 002b 4e49  ....9..;..tt.+NI</span><br><span class="line">0000010: 4b2c 8660 eb9c ecac c462 eb94 345e 2e30  K,......b..4^.0</span><br><span class="line">0000020: 373b 2731 0b22 0ca6 c1a2 d669 1035 39d9  7;&apos;1.&quot;.....i.59</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后就可以在二进制模式下编辑该文件，编辑后保存，然后用下面命令从二进制模式转换到普通模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%!xxd -r</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;另外，也可以调整二进制的显示模式，默认是 2 个字节为一组，可以通过 <code>g</code> 参数调整每组字节数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:%!xxd -g 1         表示每1个字节为1组</span><br><span class="line">:%!xxd -g 2         表示每2个字节为1组(默认)</span><br><span class="line">:%!xxd -g 4         表示每4个字节为1组</span><br></pre></td></tr></table></figure>
<h2 id="5-Vim配置"><a href="#5-Vim配置" class="headerlink" title="5. Vim配置"></a>5. Vim配置</h2><p>&emsp;&emsp;最初安装的Vim功能、特性支持比较少，用起来比较费劲，想要稍微“好用”一点，需做一些初步的配置。Vim的配置主要分为Vim本身特性的配置和外部插件的配置两部分。<br>&emsp;&emsp;Vim的配置是通常是存放在用户主目录的 <code>.vimrc</code> 的隐藏文件中的。就Vim本身特性来说，基础的配置有编程语言语法高亮、缩进设置、行号显示、搜索高亮、TAB键设置、字体设置、Vim主题设置等等，稍微高级一些的有编程语言缩进、自动补全设置等，具体配置项可以自行查资料，全面详细的配置项介绍可以参考：<br>&emsp;&emsp;<a href="http://vimcdoc.sourceforge.net/doc/options.html#%27completeopt%27" target="_blank" rel="noopener">《Vim Options》</a></p>
<h2 id="6-Vim插件"><a href="#6-Vim插件" class="headerlink" title="6. Vim插件"></a>6. Vim插件</h2><p>&emsp;&emsp;Vim“编辑器之神”的称号并不是浪得虚名，然而，这个荣誉的背后，或许近半的功劳要归功于强大的插件支持特性，以及社区开发的各种各样功能强大的插件。<br>&emsp;&emsp;平时开发人员常用插件主要是目录（文件）查看和管理、编程语言缩进与自动补全、编程语言Docs支持、函数跳转、项目管理等等，简单配置可以参考下面：<br>&emsp;&emsp;<a href="http://blog.segmentfault.com/xuelang/1190000000630547" target="_blank" rel="noopener">《Vim插件简单介绍》：</a><br>&emsp;&emsp;<a href="http://blog.csdn.net/wooin/article/details/1858917" target="_blank" rel="noopener">《手把手教你把Vim改装成一个IDE编程环境(图文)》</a><br>&emsp;&emsp;<a href="http://www.cnblogs.com/zhangsf/archive/2013/06/13/3134409.html" target="_blank" rel="noopener">《将Vim改造为强大的IDE》</a></p>
<p>&emsp;&emsp;当然，这些插件都是拜Vim本身的插件支持特性所赐。Vim为了支持丰富的第三方插件，自身定义了一套简单的脚本开发语言，供程序员自行开发自己所需要的插件，插件开发介绍可以参考：</p>
<p>&emsp;&emsp;(《Writing Vim Plugins》)[<a href="http://stevelosh.com/blog/2011/09/writing-vim-plugins/" target="_blank" rel="noopener">http://stevelosh.com/blog/2011/09/writing-vim-plugins/</a>]</p>
<h2 id="7-Vim完整文档"><a href="#7-Vim完整文档" class="headerlink" title="7. Vim完整文档"></a>7. Vim完整文档</h2><p>&emsp;&emsp;<a href="http://vimdoc.sourceforge.net/" target="_blank" rel="noopener">Vim官方文档</a><br>&emsp;&emsp;<a href="http://pan.baidu.com/s/1jGzbTBo" target="_blank" rel="noopener">Vim中文用户手册7_3.pdf</a></p>

      
    </div>
      <div id="remark"></div>
    <div class="article-info article-info-index">
      
      <a href="/2018/07/23/vim/" class="archive-article-date">
  	<time datetime="2018-07-23T12:21:21.000Z" itemprop="datePublished"><i class="icon-clock"></i>2018-07-23</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux操作/">linux操作</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vim/">vim</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vim命令/">vim命令</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/个人博客/">个人博客</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-linuxFilePath" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/17/linuxFilePath/">linux环境变量初始化与对应文件的生效顺序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;在登录Linux系统并启动一个bash shell时，默认情况下bash会在若干个文件中查找环境变量的设置。这些文件可统称为系统环境变量。bash检查的环境变量文件的情况取决于系统运行shell的方式。</p>
<p>&emsp;&emsp;系统运行shell的方式一般有三种：</p>
<p>&emsp;&emsp;一、通过系统用户登录后默认运行的shell</p>
<p>&emsp;&emsp;二、非登录交互式运行shell</p>
<p>&emsp;&emsp;三、执行脚本运行非交互式shell</p>
<p>&emsp;&emsp;当用户登录Linux系统时，shell会作为登录shell启动。此时的登录shell加载环境变量的顺序如下</p>
<p><img src="https://img-blog.csdn.net/20170724085550953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzQ4MTAyNzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>&emsp;&emsp;用户登录系统后首先会加载/etc/profile全局变量文件，这是Linux系统上默认的shell主环境变量文件。系统上每个用户登录都会加载这个文件。</p>
<p>&emsp;&emsp;当加载完/etc/profile文件后，才会执行/etc/profile.d目录下的脚本文件。</p>
<p>&emsp;&emsp;之后开始运行$HOME/.bash_profile（用户环境变量文件），在这个文件中，又会去找$HOME/.bashrc（用户环境变量文件），如果有则执行，如果没有则不执行。在$HOME/.bashrc文件中又会去找/etc/bashrc（全局环境变量文件），如果有则执行，如果没有则不执行。</p>
<p>&emsp;&emsp;如果用户的shell不是登录时启动的，非登录shell只会加载$HOME/.bashrc（用户环境变量文件），并会去找/etc/bashrc（全局环境变量文件）。如果希望在登录shell下也可以读到设置的环境变量等内容，就需要将变量设定等写入$HOME/.bashrc或者/etc/bashrc，而不是$HOME/.bash_profile或/etc/profile。</p>

      
    </div>
      <div id="remark"></div>
    <div class="article-info article-info-index">
      
      <a href="/2018/07/17/linuxFilePath/" class="archive-article-date">
  	<time datetime="2018-07-17T11:56:10.000Z" itemprop="datePublished"><i class="icon-clock"></i>2018-07-17</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/FHS/">FHS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux环境变量/">linux环境变量</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/个人博客/">个人博客</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-linuxFHS" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/17/linuxFHS/">Linux文件层级结构标准（FHS）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;设计FHS(Filesystem Hierarchy Standard)的目的主要是为了给Unix-like系统的管理员提供一个管理系统以及目录结构的一个参考。</p>
<p>&emsp;&emsp;由于利用Linux源码开发产品和发行版的企业或组织众多，如果每个组织都按照自己的喜好来组织系统中的文件结构，网络上必然出现各种各样的文件结构。这些产品的用户就不得不为每种不同的文件系统结构花费时间来学习。有了FHS之后，几乎所有的Unix-like系统的发行商或软件开发者都遵从该建议规范每个特定目录下分别只放哪些文件，方便了文件的组织和查找。</p>
<p>&emsp;&emsp;FHS也根据实际使用的需求持续更新，完整的FHS可参考（<a href="http://www.pathname.com/fhs/）" target="_blank" rel="noopener">http://www.pathname.com/fhs/）</a></p>
<p><abbr title="" style="color:#333;font-weight:bold;background:#fff;text-decoration:none;border-bottom:none;">/, /usr, /var</abbr></p>
<hr>
<p>&emsp;&emsp;FHS根据文件的可共享、不可共享、静态和动态等特点，将目录树架构分为/、/usr、/var三部分。</p>
<blockquote>
<p> / 根目录是整个系统最重要的一个目录，因为在Linux系统中所有的目录都必须挂载在根目录下，也即所有的目录都是由根目录衍生出来。系统开机是所需要的开机软件、内核文件、函数库等都必须在根目录下。因此FHS也建议根目录不要安装在非常大、数据存取非常活跃的分区上，如此一来就能尽可能地降低系统不必要的错误。建议：根目录越小越好，且应用程序安装目录不要和根目录放置于同一分区。根目录下一般建议由以下耳机子目录：</p>
</blockquote>
<ul>
<li>/bin 供所有用户使用的基本命令程序文件</li>
<li>/sbin 系统管理员使用的工具程序</li>
<li>/boot 引导加载器(bootloader)必须用到的静态文件：kernel、initramfs(initrd)、grub等</li>
<li>/dev 存储特殊文件或设备文件: 字符设备（线性设备）、块设备（随机设备）</li>
<li>/etc 系统程序的配置文件（只能为静态的，不能是二进制）</li>
<li>/lib、/lib64 为系统启动或根文件系统上的应用程序（/bin, /sbin）提供共享库（libc.so.<em> ld</em>），以及为内核提供内核模块（modules）</li>
<li>/media 便携式设备的挂载点，cdrom、floopy等</li>
<li>/mnt 其他文件系统的临时挂载点</li>
<li>/opt 第三方程序的安装位置，可选路径；</li>
<li>/srv 当前主机为服务提供的数据</li>
<li>/tmp 为那些会产生临时文件的程序提供的用于存储临时文件的目录</li>
<li>/usr user hierarchy 全局共享只读数据路径</li>
<li>/var var hierarchy存储常发生变化的文件</li>
<li>/proc 内核级进程存储其相关信息，多为内核参数，例如net.ipv4.ipforward虚拟为net/ipv4/ipforward，存储于/proc/sys</li>
<li>/sys sysfs虚拟文件系统提供了一种比proc更为理想的访问内核数据的途径；为管理内核提供了一种统一模型的接口</li>
</ul>
<blockquote>
<p> /usr 根据FHS建议软件安装后将他们的数据合理地分别放置到这个目录下，而不要自行新建该软件自己的独立目录。/usr放置的数据属于可分享的且不可变动的，/usr可分享给局域网内的其他主机来使用。</p>
</blockquote>
<ul>
<li>/usr/bin</li>
<li>/usr/sbin</li>
<li>/usr/lib</li>
<li>/usr/lib64</li>
<li>/usr/include C程序头文件</li>
<li>/usr/share 命令手册页和自带文档等</li>
<li>/usr/local 另一个层级结构，让系统管理员安装本地应用程序，通常用于安装第三方软件</li>
<li>/usr/src 程序的源码</li>
</ul>
<blockquote>
<p> /var 主要存储常变化的文件，包括缓存(cache)、登录文件(logfile)以及某些软件运行所产生的文件，包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等。</p>
</blockquote>
<ul>
<li>/var/cache 应用程序产生的缓存文件</li>
<li>/var/lib 程序执行过程中，需要用到的数据文件放置的目录。此目录下各自的软件应该要有各自的目录。</li>
<li>/var/lib 某些设备或者文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该设备时，就可能产生一些错误，因此就得要将该设备或文件上锁(lock)，以确保该文件或设备只给一个程序使用。</li>
<li>/var/log 登录文件 /var/log/messages, /var/log/wtmp</li>
<li>/var/mail 个人电子邮箱目录，通常与/var/spool/mail/目录互为链接</li>
<li>/var/run 与运行中的进程相关的数据，PID等</li>
<li>/var/spool 存放等待其他程序使用的数据</li>
<li>/var/tmp 下次启动前会被删除的临时数据</li>
</ul>

      
    </div>
      <div id="remark"></div>
    <div class="article-info article-info-index">
      
      <a href="/2018/07/17/linuxFHS/" class="archive-article-date">
  	<time datetime="2018-07-17T11:51:33.000Z" itemprop="datePublished"><i class="icon-clock"></i>2018-07-17</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/FHS/">FHS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux文件/">linux文件</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/个人博客/">个人博客</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-studyWay" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/27/studyWay/">前端网老姚浅谈：怎么学JavaScript？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>   &emsp;&emsp;鉴于时不时，有同学私信问我（老姚，下同）怎么学前端的问题。这里统一回复一下，如下次再遇到问我此问题同学，就直接把本文链接地址发给你了。</p>
<p>   &emsp;&emsp;首先说句题外话。关于有人管我叫大神的事情。个人感觉这跟你买东西时，人家管你叫帅哥一样，你答应与否都无妨。</p>
<p>   &emsp;&emsp;正题开始，“前端怎么学”应该因人而异，别人的方法未必适合自己。就说说我的学习方法吧：我把大部分时间放在学习js上了。因为这个js的学习曲线，先平后陡。项目实践和练习啥的，我不说了，主要说下工作之外的时间利用问题。我是怎么学的呢，看书，分析源码。个人这几天统计了一下，前端书籍目前看了50多本吧，大部分都是js的。市面上的书基本，差不多都看过。</p>
<p>   <abbr title="" style="color:red;font-weight:bold;text-decoration: none;">第一个问题是，看书有啥好处？</abbr></p>
<p>   &emsp;&emsp;好处应该是不言而明的，书看多了，基础会逐渐夯实起来。看多了，自己的判断力，自然就上来了。看别人的文章，就能很快判断出，对方每块儿讲得对不对，哪块儿又是自己不清楚的，模棱两可的。当然也为看源码，分析源码提供了基础。</p>
<p>   &emsp;&emsp;<abbr title="" style="color:green;text-decoration: none;">10本书读2遍的好处，应该大于一本书读20遍</abbr>。10本书的交集，那就是基础知识的核心，而并集那就是所有的知识。好书当然要多读，反复读。但是只读一本是不行的。因为每本书的侧重点都不一样。从不同的侧面，去理解一个知识点，是很有意义的。</p>
<p>   &emsp;&emsp;所以特别佩服印度人，他跟你讲英文，你一个词语没听懂，他会蹦出n个同一意思的单词，你听懂一个，就ok了。看书也是这样的，某一块讲得不透彻，不用担心，其他书籍可以帮助你来了解。</p>
<p>   <abbr title="" style="color:red;font-weight:bold;text-decoration: none;">第二个问题是，书籍推荐。</abbr></p>
<p>   &emsp;&emsp;个人觉得不错的，没事可以翻翻的。书籍如下：</p>
<p>   &emsp;&emsp; <abbr title="" style="color:green;text-decoration: none;">&gt;《javascript面向对象编程指南》</abbr>，风格轻松易懂，比较适合初学者，原型那块儿讲得透彻，12种继承方式呢。</p>
<p>   &emsp;&emsp; <abbr title="" style="color:green;text-decoration: none;">&gt;《js权威指南》、《js高级程序设计》</abbr>，这两本书经典是经典，但是太厚，适合把其中任意一章都当成一本书来读。洋洋洒洒，很难一口气看完。比较适合当做参考书。</p>
<p>   &emsp;&emsp; <abbr title="" style="color:green;text-decoration: none;">&gt;《你不知道的javascript》</abbr>狙击js核心细节，闭包、原型、this讲得都还清楚。目前《中册》也出了，还在看。</p>
<p>   &emsp;&emsp; <abbr title="" style="color:green;text-decoration: none;">&gt;《js设计模式与开发实践》</abbr>js设计模式也是要学的，此书把js的设计模式讲得非常清晰，一点不晦涩，看起来没多少难度。</p>
<p>   &emsp;&emsp; <abbr title="" style="color:green;text-decoration: none;">&gt;《正则指引》</abbr>，分析源码时，如果正则表达式不懂，没法进行下去的。此书相对来说讲得比较清晰。</p>
<p>   &emsp;&emsp; <abbr title="" style="color:green;text-decoration: none;">&gt;《基于MVC的JavaScript Web富应用开发》</abbr>，看完后，基本能写出自己的mvc框架了。是本好书。</p>
<p>   &emsp;&emsp; <abbr title="" style="color:green;text-decoration: none;">&gt;《javascript函数式编程》</abbr>，js是一门函数式语言，此书是函数式编程一个入门，函数是一等公民那是非常重要的。</p>
<p>   &emsp;&emsp; <abbr title="" style="color:green;text-decoration: none;">&gt;《js忍者秘籍》</abbr>，jq作者写的，没有传说中的那么难读，话说就算你看完并理解所有知识点，也不会达到世界高手级别的。因为你还没有做到随心所欲。</p>
<p>   &emsp;&emsp; <abbr title="" style="color:green;text-decoration: none;">&gt;《javascript框架设计》</abbr>，如果初看此书，会觉得此书有罗列代码之嫌。在我看来，此书讲究的是框架的全局观。以上书籍是我认为是成就高手之路上必须看的，也需要反复看。</p>
<p>   &emsp;&emsp; css相关的书籍，说实话我看得比较少，总共有六七本吧。有两本必须推荐一下：</p>
<p>   &emsp;&emsp; <abbr title="" style="color:green;text-decoration: none;">&gt;《css权威指南》</abbr>，css基础知识点那是讲得非常清楚的。什么层叠优先级、line-height啥的。不是随便一本书都敢叫“权威指南”的。</p>
<p>   &emsp;&emsp; <abbr title="" style="color:green;text-decoration: none;">&gt;《css揭秘》</abbr>，此书我也是不断的看，此书才不屑于全面讲css3各属性呢。css规范文档能讲的，它只会讲你最不在意的。此书解决的47问题，解决思路和解决方案同等重要，很有启发性。以上各书你都可以不买，至少买本此书吧。</p>
<p>   <abbr title="" style="color:red;font-weight:bold;text-decoration: none;">第三个问题，怎么看。</abbr></p>
<p>   &emsp;&emsp;想必很多同学，都想看书，但是很难看下去。文字部分相对来说还能看看，一遇到代码，头皮就发麻了。此问题一开始时我也遇到的。</p>
<p>   &emsp;&emsp;说一个学习理论。比如说学英语，有个开水理论。词汇量必须达到6000才行，如果没达到，英文水平不会上去的，这跟烧开水一样，没事烧烧，放着凉凉，从来没烧到100度，那么此水是永远不能喝的。一旦煮沸过，就可以随时喝了。</p>
<p>   &emsp;&emsp;20本书你看不下去，说明什么呢？<abbr title="" style="color:green;text-decoration: none;">任何一本书，你都没看完过。</abbr>熟悉的，永远只是前三章。别笑，我原先也是这样的。</p>
<p>   &emsp;&emsp;那么现在的问题是，怎么把一本书看完呢？<abbr title="" style="color:green;text-decoration: none;">很简单，敲。</abbr>《基于MVC的JavaScript Web富应用开发》这本书我看时，就是这样，终于有一天，我下定决心要把此书从头到尾敲一遍。文字加代码都敲，然后就一章一章得看完了。代码敲一遍后，你会发现，没之前看起来的那么难。</p>
<p>   &emsp;&emsp;如果你属于一看书就犯困那种同学。<abbr title="" style="color:green;text-decoration: none;">强烈建议你把《javascript面向对象编程指南》此书从头到尾敲一遍。</abbr>坚持看完一本书后，信心就上来了。先保证看完一本再说,看完3本后，基本应该能做到几天就能看一本了。万事开头难，加油吧。</p>
<p>   <abbr title="" style="color:red;font-weight:bold;text-decoration: none;">第四个问题，看书的层次问题。</abbr></p>
<p>   &emsp;&emsp;书看完后，要自己总结，要与其他书籍对比看。有同学同时对比着看《权威指南》和《高设》来的。随便拿出个知识点，你都能闭着眼睛说得头头是道，说明水平够了。</p>
<p>   &emsp;&emsp;下一块就是<abbr title="" style="color:green;text-decoration: none;">源码的学习</abbr>了。看框架源码之前，想说一件事情：dom的api不懂，没问题，你可以百度。</p>
<p>   &emsp;&emsp;但是正则一定要先研究研究，不然大多数人去尝试分析源码时，遇到的挫折都在于此。</p>
<p>   <abbr title="" style="color:green;text-decoration: none;">怎么去阅读源码呢？敲，照着敲。</abbr></p>
<p>   &emsp;&emsp;有哪些代码值得去敲呢？优秀框架或者库的源码都值得你去敲。但是拿jq来敲，来入门，那不行的。原因：太他么长了。八九千行呢！！</p>
<p>   &emsp;&emsp;个人觉得<abbr title="" style="color:green;text-decoration: none;">underscore.js</abbr>库是不错的第一个选择。原因都是工具方法，敲完以后自己的水平应该略有小成吧。其实有一些api的实现，你要把它当成getElementById一样，深深的印在脑海里。比如extend方法，必须张口就来。敲完underscore库后，可以考虑去看看《javascript函数式编程》这本书了。</p>
<p>   &emsp;&emsp;jq的源码不好敲。那么<abbr title="" style="color:green;text-decoration: none;">zepto</abbr>的源码比较少1800多行，敲一天应该敲完了。敲几遍后，把所有不懂的地方，都百度清楚，然后就可以写自己的类jq的库了。然后就可以作为一项技能写进自己的简历里。比如“创建过自己的jquery库”。当然敲的过程，还能帮助自己对jq的api认识。</p>
<p>   &emsp;&emsp;然后是<abbr title="" style="color:green;text-decoration: none;">backbone.js</abbr>，因为此框架是以类jq和underscore为基础的mvc框架。代码也没多少行。敲吧。spine.js与backbone类似。可以在敲其之前，先看看那本《基于MVC的JavaScript Web富应用开发》。希望你的简历可以添加这么一笔，“创建过自己的mvc框架”。</p>
<p>   &emsp;&emsp;其他的，我也敲过一些。包括<abbr title="" style="color:green;text-decoration: none;">jq.validate.js</abbr>，包括一些插件。如果你愿意的话，bootstrap你可以去敲敲啊。源码挺多的，可以按插件逐个来敲。分析明白了，轮播、分页、下拉框等等的插件那还不是分分钟随手就写一个了。最起码看看人家api接口是怎么设计的也是极好的。话说个人在阅读其css代码中，也学到了不少东西。说到插件，有两个必须提提，一个是表格插件，一个是树。都敲完，简历里可以这么写上，“创建过自己的UI框架”。</p>
<p>   &emsp;&emsp;当然了，你也可以敲你喜欢的框架代码，重要的是明白其<abbr title="" style="color:green;text-decoration: none;">实现原理</abbr>，最好理解其为啥那么设计，如果对设计模式比较熟悉的话，会经常发现原来是这么回事。</p>
<p>   &emsp;&emsp;照着敲只是分析源码的入门，用途也是为了学习，最后能用在自己的项目中，那是才是正道。就算没啥用，也是打发时间的好方式，比看电视剧强多了。我闲着无聊时，就背着敲underscore源码。最后说句，如果你简历上能如期写上那几句话后，必须是大神。加油吧。</p>
<p>   <abbr title="" style="color:#333;font-weight:bold;text-decoration: none;">后记</abbr></p>
<p>   &emsp;&emsp;写本文的最初目的，正如文章开头说的那样，方便自己回复大家的提问。本站的任何一篇分享学习经验的文章，基本都会引起共鸣，这确实是一个值得讨论的话题。这里再说说几个事情。</p>
<p>   &emsp;&emsp;<abbr title="" style="color:green;text-decoration: none;">&gt;有人问我前端工作经验事情。<abbr></abbr></abbr></p>
<p>   &emsp;&emsp;没几年。三年多。</p>
<p>   &emsp;&emsp;<abbr title="" style="color:green;text-decoration: none;">&gt;初学者或新手（beginner）怎么办？<abbr></abbr></abbr></p>
<p>   &emsp;&emsp;看书和分析源码是重要的提高方式，但不适合新手。新手需要的是能快速的入门和入行，能快速的上手工作。一种快捷的学习方式就是看视频。正如有的同学说得那样，知道有哪些东西，怎么用就可以了。</p>
<p>   &emsp;&emsp;看视频是有好处的，首先它是一种被动学习方式。我最开始的入门也是看视频来的，只需要看就行了。一遍没懂，再放一遍，我基本上是1.5倍数去看的。</p>
<p>   &emsp;&emsp;而读书是一种主动方式，需要自己一页一页翻。需要自己主动的去理解。而很多东西，也许只是视频老师一句话，就能突出的重点，需要我们自己去解读。还有另一件事情是，比如发现自己某个知识点不太清楚，可以单独去百度。比如this，文章很多的。这种学习方式也是快速掌握知识点的好办法。</p>
<p>   &emsp;&emsp;书籍需要技术评审，那么看文章一定要看看评论。不过视频就不好说了，视频一般都不会讲得太深入，偶尔也有讲错的。当年我也曾被一些视频误导过，建议找不错的视频看看。各大网站培训机构的免费视频挺多的。</p>
<p>   &emsp;&emsp;<abbr title="" style="color:green;text-decoration: none;">&gt;看书和分析源码的时机。<abbr></abbr></abbr></p>
<p>   &emsp;&emsp;但已经工作一年半载时，正是提高的好时候，此时可以去看书了。全面系统的梳理知识点，扫清自己的盲区。如果只是靠项目经验是不够的，通过项目来学习，那肯定是必须的，工作本身就是一个学习的过程。</p>
<p>   &emsp;&emsp;但是工作三年不看书的话，学又能学到多少呢？更何况每个项目都很类似，一直处在舒适区，那真就是5年经验重复第一年的了。所以我不认同这句话：面试时强调自己的学习能力是工作能力不强的表现。3年经验的水平，完全有可能超过5年的。</p>
<p>   &emsp;&emsp;<abbr title="" style="color:green;text-decoration: none;">&gt;没有时间去学习？<abbr></abbr></abbr></p>
<p>   &emsp;&emsp;如果你还没毕业，就已经天天在本站混了，其实你领先了一大步。都是混过大学的，天天充斥着lol和电视剧的陪伴，我只想说进入社会是要还的。最可怕的是什么呢？该还、还不还（这几个字别念错了）。时间是有的，就看你愿意付出不。下班后学习，周末学习，节假日别人玩的时候，在家敲代码，这样才能领先别人。</p>
<p>   &emsp;&emsp;<abbr title="" style="color:green;text-decoration: none;">&gt;兴趣问题？<abbr></abbr></abbr></p>
<p>   &emsp;&emsp;兴趣和擅长是一个良性迭代循环。你擅长某件事情，就会越喜欢它，越喜欢，就越愿意花时间，进而越擅长。此道理都懂，只是缺乏一个trigger。</p>
<p>   &emsp;&emsp;如果你喜欢玩游戏的话，其实你可能非常适合做前端。玩游戏就是一个反馈机制，前端工作的反馈，相对其他工作来说也是非常及时的。代码一改，网页一刷，就看到效果了。擅长、优越感、成就感通常都是连在一起的。每看完一本书，我都觉得很有成就感。每敲完一个库，也有成就感。</p>
<p>   &emsp;&emsp;以上纯属一家之言，每个人的学习习惯、方式、态度都不一样。先端正态度、找到自己的学习方法，进而养成坚持下去的习惯。最后说一句，你我共勉：只要你走在正确的道路上，不管、走得多慢，都是前进！</p>
<p>   &emsp;&emsp;本文完。</p>

      
    </div>
      <div id="remark"></div>
    <div class="article-info article-info-index">
      
      <a href="/2018/02/27/studyWay/" class="archive-article-date">
  	<time datetime="2018-02-27T03:22:51.000Z" itemprop="datePublished"><i class="icon-clock"></i>2018-02-27</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/全栈/">全栈</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端学习/">前端学习</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/个人博客/">个人博客</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-webDevelopment" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/27/webDevelopment/">技术人员的发展之路</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>译注：本文作者酷壳/陈皓</p>
</blockquote>
<p>   &emsp;&emsp;2012年的时候写过一篇叫《程序算法与人生选择》的文章，我用算法来类比如何做选择，说白了就是怎么去计算，但是并没有讲程序员可以发展的方向有哪些。 所以，就算是有这些所谓的方法论，我们可能对自己的发展还是会很纠结和无所事从，尤其是人到了30岁，这种彷徨和迷惑越来越重。虽然我之前也写过一篇《编程年龄和编程技能》的文章，但是还是有很多做技术的人对于自己能否在年纪大时还能去做技术感到没有信心。我猜测，这其中，最大的问题的是，目前从事技术工作的种种负面的经历（比如经常性的加班，被当成棋子或劳动力等等），让人完全看不到希望和前途，尤其是随着年纪越来越大，对未来的越来越没有信心。<br>   &emsp;&emsp;同时，也是因为在GIAC的大会被问到，程序员老了怎么办？而在年底这段时间，也和几个朋友在交流中不断地重复谈到个人发展的这个话题。我的人生过半，活到“不惑”的年纪，自然经常性的对什么事都会回头看看总结归纳，所以，在交谈过程中和交谈过后，自己也有一些思考想记录下来。因为我本人也是在这条路上的人，所以，谈不上给他人指导，我同样也是在瞎乱折腾同样每天在思考自己要去哪儿的“一尘世间迷途老生”。况且，我的经历和眼界非常有限，因此，下面的这些关于个人发展的文字和思考必然是受我的眼界和经历所局限的。也欢迎大家补充和指正。<br>   &emsp;&emsp;这些东西不一定对，也不一定就是全部，期许可以让你在年底的时候有所思考，在明年的时候有所计划。</p>
<p>   <abbr title="" style="color:red;font-weight:bold;text-decoration: none;">一个重要阶段和标志</abbr></p>
<p>   &emsp;&emsp;在讲个人发展之前，我需要先说一下人生中的一个非常重要的阶段——20到30岁！<br>   &emsp;&emsp;这个阶段的首要任务，就是提升自己学习能力和解决难题的能力。这是一个非常非常关键的时间段！这个时间段几乎决定着你的未来。<br>   &emsp;&emsp;30岁以前，这个时间段，应该是人学习和积累的时间段，这个时间段，就是努力学习的时间段。这个时间段，你一定要把时间花在解决问题的技能上。就是说，你一定要练就成的技能是——你能解决大多数人不能解决的问题。使蛮力埋头加班苦干，当一个搬砖老黄牛的是肯定没有前途的。如果你不幸呆在了一个搬砖的地方，天天被业务压得喘不过气来，我建议你宁可让你的项目延期被老板骂，也要把时间挤出来努力学习基础知识，多掌握一些技术（很多技术在思路上是相通的），然后才能有机会改变自己目前的状况。因为，比起你的个人未来，项目延期被老板骂、绩效不好拿不到奖金，都不是什么事儿。<br>   &emsp;&emsp;总结一下，你在30岁前，工作5-7年，你需要拥有：</p>
<p>   &emsp;&emsp;&hearts; 高效的学习能力。这意味着——基础知识扎实、触类旁通、读英文文档不费劲、有寻找前沿知识的能力、能够看到问题和技术的本质、善于思辩、能独立思考。<br>   &emsp;&emsp;&hearts; 解决问题的能力。这意味着——你要高效的学习能力、见过很多的场景、犯过或是处理很多错误、能够防火而不是救火。</p>
<p>   &emsp;&emsp;如果你拥有这两个能力的现象是—— 在团队或身边的人群中的显现出Leadership。<br>   &emsp;&emsp;Leadership并不是当领导和经理，而是一种特征，这种特征有如下两个简单的表象：</p>
<p>   &emsp;&emsp;&hearts; 帮人解问题。团队或身边中大多数人都在问：“这问题怎么办？”，而总是你能站出来告诉大家这事该怎么办？<br>   &emsp;&emsp;&hearts; 被人所依赖。团队或身边中大多数人在做比较关键的决定时，都会来找你咨询你的意见和想法。</p>
<p>   &emsp;&emsp;一但你在在30岁之间出现了Leadership这样的特征，那么，你会进入一个正循环的阶段：</p>
<p>   &emsp;&emsp;&hearts; 因为你学习能力强，所以，你会有更多的机会解决难题。<br>   &emsp;&emsp;&hearts; 你有更多的机会解决难题，你就会学更多的东西，于是你就会更强。<br>   &emsp;&emsp;&hearts; 上面这个循环，只要循环上几年，就会让你人生的各种可能性大大的增加。</p>
<p>   &emsp;&emsp;【 注意 】<br>   &emsp;&emsp;&hearts; 要达到这样的特质，需要找到自己的长处、以及适合自己的环境。就像鱼的特长是呆在水里，让鱼儿去追求陆上动物的刺激生活并不靠谱。<br>   &emsp;&emsp;&hearts; 一般说来，有这样的潜质的人，在学校中就应该要出现。如果你在大学中还没有出现这样的潜质，那么，你在工作当中要加倍努力了（注：所谓的加倍努力，不是让你使蛮力加班，而是让你多学习成长，使蛮力拼命是弥补不了能力、思维、眼界上的缺陷的）。<br>   &emsp;&emsp;&hearts; Leadership也有范围的，比如，身边的朋友，工作中的团队/部分，圈内，整个行业。Leadership的范围越大，你的个人发展的选择性就越高。反之则越小。<br>   &emsp;&emsp;&hearts; 如果已到了30岁左右，还是没有出现这样的特征。那么，可能未来你也很难有这样的Leadership了。而你的个人发展的可能性可能也就不多了（sigh…）</p>
<p>   &emsp;&emsp;读到这里，我必需要说一下，如果你已开始显现出你的Leadership，那么你才谈得上个人发展，这篇文章后续的内容也可能才会对你有意义。</p>
<p>   <abbr title="" style="color:red;font-weight:bold;text-decoration: none;">个人发展的三个方向</abbr></p>
<p>   &emsp;&emsp;以我个人短浅的经历和视野，目前只看到的人的发展有如下三个大方向（他们之间可能会有重叠）：</p>
<p>   &emsp;&emsp;1）在职场中打拼<br>   &emsp;&emsp;2）去经历有意义有价值的事<br>   &emsp;&emsp;3）追求一种自由的生活</p>
<p>   &emsp;&emsp;这三个方向，我个人或多或少都体验过，我也见过身边的很多人走这三个方向走的比较成功。也许还有别的方向，没办法，现在，我的视野就这么大，所以，我在这里，我主要就是谈谈这三个方向。Again，人有资格去走这三个方向的前提是——已有了上面我说的Leadership那种特质！</p>
<p>   <abbr title="" style="color:red;font-weight:bold;text-decoration: none;">一、在职场中发展</abbr></p>
<p>   &emsp;&emsp;在职场中发展应该是绝大多数人的选择。通过加入公司来达到人生的发展。</p>
<p>   &emsp;&emsp;我们经常可以看到很多所谓的“职业规划”，但是大多数职业规划只不过人力资源搞出来的东西，和实际其实是有很大出入的。我的人生经历中，有18年左右是在公司中度过的，在过银行，小公司，大公司，民营公司，外国公司，传统IT公司，互联网公司，不同的公司完全有不同的玩法和文化，我的经历还算丰富，但也不算特别成功，这里只分享一些我在职场中的心得（不一定对，仅供参考）。</p>
<p>   &emsp;&emsp;<abbr title="" style="color:green;text-decoration: none;">1、去顶尖公司</abbr></p>
<p>   &emsp;&emsp;去顶尖公司的一个目的就是让你的Leadership的范围的可能性扩大。<br>   &emsp;&emsp;因为公司和公司的差距也不小，所以，就算你在低端公司里是骨干份子，但在高端公司里可能只是一个普通员工（就像中国足球队的主力到了英超可能都无法入选）。所以，在职场中，如果你要让你的个人价值最大化的话，你一定要去顶尖的公司。因为顶尖公司里有非常不错的工作方法和场景，这并不是能看书或是交流得来的，这是必需要去亲身体验的。所以说，在顶尖公司掌握的技能，开阔的眼界，通常来说都会比低端公司的要多得多。<br>   &emsp;&emsp;另外，每个公司的工作级别都是有相互对标的，比如：阿里的P几对应于百度的T几。国内的一线公司职位还相当，但是如果和国外一线公司的比，那就有差距了，而且差距还很大。比如，Google或Facebook的某个高级工程师，可能就对应于阿里的P8/P9甚至更高。<br>   &emsp;&emsp;是的，对于职场来说，如果你在顶尖公司是骨干，那么，你去低端公司，则有很大机会会成为他们高管和核心。就好像你在Facebook里干三五年成为他们的技术骨干，那么你到BAT去成成为高管概率是非常大的。反过来，如果你毕业主去了BAT成为了一个螺丝钉，在天天加班中度过你的青春，你干个十年能成为BAT的高管的概率可能会非常的低。</p>
<p>   &emsp;&emsp;<abbr title="" style="color:green;text-decoration: none;">2、去真正的创业公司</abbr></p>
<p>   &emsp;&emsp;去顶尖公司和去创业公司在某些时候并不冲突。不过，这里我想讲的是，一个技术能力强的人在大公司可能会被埋没掉。因为大公司业务成功后，</p>
<p>   &emsp;&emsp;&hearts; 成功的公司在招聘各种高级技术人才都不会成为问题，于是少你一个不少，多你一个不多。<br>   &emsp;&emsp;&hearts; 成功的公司其整个技术体系已经完成，Legacy的问题也比较多，所以，可以供你发挥的余地不大。<br>   &emsp;&emsp;&hearts; 成功的公司更多的可能会想要稳定的系统，稳定必然会产生保守，而保守则产生不思进取。</p>
<p>   &emsp;&emsp;所以，对于中高级人才来说，在大公司里的能产生的个人价值，可能远远不如那些求贤若渴、没有包袱、可以尽情施展、相对更为灵活和自由的创业型公司。<br>   &emsp;&emsp;不过，去创业公司需要小心仔细的挑选和评估，创业公司的不确定因素很多，也和创始人的因素太大了，所以，你需要小心了解创始人和他们的业务情况，想法和理念差不多才能更好的共事。<br>   &emsp;&emsp;好多创业公司其实并不是真正的创业公司，他们创业有很大的侥幸和驱利心理，要小心甄别。因为那不是真正的创业公司。</p>
<p>   &emsp;&emsp;<abbr title="" style="color:green;text-decoration: none;">3、职业生涯的发展阶段</abbr></p>
<p>   &emsp;&emsp;首先，有一个不争事实——整个社会是会把最重要的工作交给30岁左右的这群人的。也就是说，30岁左右这群人是这个社会的做事的中坚力量。<br>   &emsp;&emsp;所以，这是一个机遇！如果你有了Leadership，你就一定能在这个时间段内赶得上这个机遇——公司和领导对你寄于信任和厚望，并把重要的团队和工作交给你。<br>   &emsp;&emsp;于是，你的30岁到40岁就成了一个职业生涯的发展期，也就是你的事业上升期。如果你到40岁都没有赶上，那么你的职业生涯也就这样了，老有所成的人是少数。<br>   &emsp;&emsp;在你事业的上升期，你需要更多的软技能，比如：</p>
<p>   &emsp;&emsp;&hearts; 带领产品和业务的发展的能力<br>   &emsp;&emsp;&hearts; 推行自己喜欢的文化的能力<br>   &emsp;&emsp;&hearts; 项目管理的能力——在任务重、时间紧中求全<br>   &emsp;&emsp;&hearts; 沟通和说服别人的能力<br>   &emsp;&emsp;&hearts; 解决冲突的能力<br>   &emsp;&emsp;&hearts; 管理和发展团队的能力<br>   &emsp;&emsp;&hearts; 解决突发事件的应急能力<br>   &emsp;&emsp;&hearts; …… ……</p>
<p>   &emsp;&emsp;另外，你还要明白在职场里的几个冷酷的事实：</p>
<p>   &emsp;&emsp;&hearts; 你开始要关心并处理复杂的人事。尤其在大公司，大量的人都是屁股决定脑袋，利益关系复杂，目标不一致，每个人心里都有不一样的想法。这个时候再也不是 talk is cheap, show me the code！而是，code is cheap，talk is the matter。你需要花大量的时间去思考和观察形形色色的人。需要耗费大量的精力在不同的人之间周旋，而不是花时间去创造些什么有价值的东西。<br>   &emsp;&emsp;&hearts; 你要开始学会使用各种政治手段。办公室政治不可避免，越大的公司越重，自从你开始成为一线的leader的那一天起，你就开始成为“里外不是人”的角色，需要在下属和领导，员工和公司之间周旋。随而你的级别越来越高，你需要使用更多的政治手段，你会学会审时度世的站队，学会迎合员工和领导，学会用官员的语言说话，学会此一时彼一时，学会妥协和交换，学会忍气吞声，学会在在适当的时机表现自己，学会波澜不惊，学会把自己隐藏起来，甚至你还会迷失自我，开始学会一些厚黑学，比如不得不在适当的时机在背后捅人刀子……你可能会成为一个你自己都讨厌的人。</p>
<p>   &emsp;&emsp;听上去真的好无聊，所以，你现在也明白为什么高层们都看上去很忙很累，而且抽不出时间来关心细节问题，因为，他们更多的是要协调整个组织和系统来运转，甚至还要四处周旋，各种博弈，没办法，这是职场的必需的东西！听起来是不是感觉人类很愚蠢？这真是没办法的事。如果你不想或是也没有能力玩这些东西，那么你需要去那些可以让技术人员安安心心做技术的公司。这类的公司，我见过Microsoft、Google、Amazon或是一些创业公司里都有。国内的大公司中也有让技术人员成长的职业成长线，但老实说，表面上看似是一个让人专心做技术的升职成长线，但其实还是管理岗位。<br>   &emsp;&emsp;所以，技术人员在职场中的归宿有两条路 —— 到真正的技术公司成为一个专心做技术的人，或是在成为一个职业的经理人。</p>
<p>   <abbr title="" style="color:red;font-weight:bold;text-decoration: none;">一个重要阶段和标志</abbr></p>
<p>   &emsp;&emsp;先说三个故事，</p>
<p>   &emsp;&emsp;&hearts; 第一个，是在阿里的时候，有一天在内网里看到一个贴子，一个做产品的女孩说自己准备离职要去法国学烘培厨艺，引得大家热评。<br>   &emsp;&emsp;&hearts; 第二个，是在亚马逊的美国老板，他每年都要去报个培训班学一个技能，比如：厨艺、开双翼飞机、夜总会里的DJ……、甚至去华盛顿去学当一个政客。<br>   &emsp;&emsp;&hearts; 第三个，是在汤森路透工作时，一个英国的同事，有一天他说他离职了，和自己的老婆准备用余生去周游世界，我问他是不是有足够多的钱了？他和我说，钱不够，他俩口子的计划是，边旅游边打工，打工打够到下一站的钱就走。他还说，那种用假期去另一个城市的旅游太没意思了，如果你不在那个地方生活上一段时间 ，你怎么能算是好的旅游体验呢？好吧，无法反驳。</p>
<p>   &emsp;&emsp;我是觉得他们把自己的人生过得如此有意思，令我很佩服。虽然跨界跨得有点猛，但是 Why Not？<br>   &emsp;&emsp;在这里，我想说，去追求一种和众人不一样的人生经历也是一件挺好的事，我个人感觉，比起在职场里有趣地多多了。如果你厌倦了职场，其实为什么不去追求一下不同的人生经历呢。就算你不想去追求跨度比较大的人生经历，那么，在技术圈里，也有很多有价值有意思的经历也可以去的。追求刺激有意义的与众不同的经历的人，其实也能算是一种人生的成功，不是吗？<br>   &emsp;&emsp;如果只说技术方面，我个人看到的去追求经历的人，有两种追求的人其实也很成功的：</p>
<p>   &emsp;&emsp;&hearts; <abbr title="" style="font-weight:bold;text-decoration: none;">到技术创新的发源地去经历创新。</abbr>计算机互联网各种技术的创新引擎，基本上来说，就是在美国了。我们赶上了这个时代，也选对了这个时代最火热的行业，那么，有什么理由不去这个时代的技术发动机那里去经历呢？在美国硅谷湾区，无论是大公司，还是创业公司，都在迸发着各式各样的创新，如果有能力有机会，为什么不努力去经历一下呢？不经历一下，老了不会觉得错过了是一种后悔吗？<br>   &emsp;&emsp;&hearts; <abbr title="" style="font-weight:bold;text-decoration: none;">去经历下一个热点技术的发展。</abbr>从IT，到互联网、再到移动互联网、云计算、大数据，再到未来的AI，VR，IoT……，技术创新的浪潮一波接一波的过来，你是想在那继续搬砖搬下去，是想迎浪而上去经历浪潮，还是想成为一个随波逐流的人？</p>
<p>   &emsp;&emsp;打工也好，创业也好，在国内也好，在国外也好，这些都是形式，不是内容。内容则是你有没有和有想法的人去经历有意义有价值事？人生苦短，白驹过隙，我们技术人员最大的幸运就是生在这样一个刺激的时代，那么，你还有什么理由不去追逐这些前沿刺激的经历呢？</p>
<p>   <abbr title="" style="color:red;font-weight:bold;text-decoration: none;">三、追求自由的生活</abbr></p>
<p>   &emsp;&emsp;我相信“自由”这个事，是所有人的心中都会想去追求的。“生命诚可贵，爱情价更高，…… ”（哈哈）<br>   &emsp;&emsp;但一说起自由，绝大多数人都想到的是“财富自由”或是“财务自由”，其实，并不完全是这样的，在自由的通路上，我个人的经历告诉我，其实，你会有很多的不同类型的自由。下面，是我对几个层次的“自由”的理解。<br>   &emsp;&emsp;<abbr title="" style="font-weight:bold;text-decoration: none;">第一层自由——工作自由。</abbr>人的第一层自由的境界是——“工作自由”，我到不是说你在工作单位上可以很自由，虽然有特例，但并不普遍。我想说的“工作自由”是——你不会有失业危机感了。也就是说，你成了各个公司的抢手货，你不但不愁找不到工作，而且你是完全不愁找不到好工作。试想一下，如果是工作来找你，一方面，你就有真正意义上的工作选择权了，另一方面，你都不愁工作了，你完全就可以随时离职去干你想干的事了。此时，你就达到了“工作自由”。<br>   &emsp;&emsp;<abbr title="" style="font-weight:bold;text-decoration: none;">第一层自由——技能自由。</abbr>工作自由已是不错，不过前提是你还是需要依赖于别人提供的工作机会。而技能自由则是你可以用自己的技能养活自己，而不需要去公司里工作。也就是所谓的自由职业者了，社会上，这样的人也不少，比如，一些健身体育教练、设计师、翻译者、作者……这些都可以算是自由职业者，程序员这个职业中只要不是搬砖的，有想法的，就有可以成为自由积业者的潜质，想一想，你拥有的编程能力，其实是一种创造的能力，也就是创造力，只要你Make Something People Want（YC创业公司的slogan），你是完全可以通过自己的技能来养活自己的。如果你通过某些自动化的东西，或是你在App上做了一个软件个体户，让自己的收入不断，甚至你做了一个开源软件，社区每个月都给你捐款捐到比你打工挣的还多，那么你就真正的有了技能自由了。<br>   &emsp;&emsp;<abbr title="" style="font-weight:bold;text-decoration: none;">第一层自由——物质自由。</abbr>我把财务自由换了一种说法。我个人觉得，除了有个好爸爸之外这种特例的情况，如果你想有物质自由的话，本质上来说，你一定要学会投资，投资不一定是你的钱，时间也是一种财富，年轻更是，你怎么投资你的时间还有你的青春？你要把你的投资投到什么样的事，什么样的人？对于投资这个事，风险也比较大。但是，人生不敢冒险可能才是最大的冒险。这个世界有很多技术不是你能看书学来的，而要只能在实战中学会的，比如：游泳。投资可能也是一种。只有真正懂投资的人，或是运气非常好的人，才可能实现物质自由。</p>
<p>   &emsp;&emsp;追求自由的生活，其实也是个人发展道路上的一个不错的选择。通常来说，自由的人，能力都不差，钱也不会少。因为，他们懂得投资。<br>   &emsp;&emsp;也就是说，拥有追求自由能力的的人，</p>
<p>   &emsp;&emsp;&hearts; 不但有领导力和创造力（也可指导大多数人并走在大多数人前面）<br>   &emsp;&emsp;&hearts; 同时他还懂得怎么投资（知道时间和精力和金钱应该投在什么地方）</p>
<p>   &emsp;&emsp;注：这里我没有提精神自由，老实说，精神上的自由我也不清楚是什么东西，因为我还没有见过，眼界有限，所以先按不表了，不然真成鸡汤文了）</p>
<p>   <abbr title="" style="color:red;font-weight:bold;text-decoration: none;">总结</abbr></p>
<p>   &emsp;&emsp;无论是在职场中打拼，还是追求精彩的经历，还是去实现自由，我觉得都是不错的个人发展的方向。<br>   &emsp;&emsp;他们都有重叠，比如：</p>
<p>   &emsp;&emsp;&hearts; 你可以在职场中去追求那些刺激的经历的公司。<br>   &emsp;&emsp;&hearts; 同样也可以通过加入有潜力高速发展的公司来达到自由。<br>   &emsp;&emsp;&hearts; 你也可以通过追寻不一样的经历来达到人生的自由。<br>   &emsp;&emsp;&hearts; ……</p>
<p>   &emsp;&emsp;总之，这里的逻辑是——</p>
<p>   &emsp;&emsp;&hearts; 能够去规划自己的个人发展的人，通常都是有很多机会和可能性的人。<br>   &emsp;&emsp;&hearts; 有很多机会和可能性的人，通常都是有Leadership，喜欢冒险的人。<br>   &emsp;&emsp;&hearts; 有Leadership喜欢冒险的人，通常都是学习能力强，思维活跃，喜欢折腾，懂得“投资”的人。<br>   &emsp;&emsp;&hearts; 学习能力强思维活跃的人，通常来说，都是喜欢看书，喜欢实践和新鲜事物，不怕艰难和挑战，用智力而不是使蛮力的人。<br>   &emsp;&emsp;&hearts; 懂得“投资”的人，通常来说，他们更多的关注的是未来和长远的成长，而不是当下的KPI、奖金和晋升。</p>

      
    </div>
      <div id="remark"></div>
    <div class="article-info article-info-index">
      
      <a href="/2018/02/27/webDevelopment/" class="archive-article-date">
  	<time datetime="2018-02-27T02:52:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2018-02-27</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术发展/">技术发展</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/个人博客/">个人博客</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-license" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/25/license/">开源许可证license选择</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><abbr style="color:orange;font-weight:bold;font-size:16px;letter-space: 2px;margin-bottom:10px;">什么是license</abbr></p>
<p>&emsp;&emsp;开源许可</p>
<p><abbr style="color:orange;font-weight:bold;font-size:16px;letter-space: 2px;margin-bottom:10px;">常用的license有哪些</abbr></p>
<p>&emsp;&emsp; 世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。最流行的六种是—-GPL、BSD、MIT、Mozilla、Apache和LGPL;</p>
<p><abbr style="color:orange;font-weight:bold;font-size:16px;letter-space: 2px;margin-bottom:10px;">如何选择</abbr></p>
<p>&emsp;&emsp;对于以上6种开源软件许可，乌克兰程序员Paul Bagwell清楚地描述了它们的一些重要的约束：</p>
<p><img src="http://hi.csdn.net/attachment/201202/5/38193_1328456263rAUA.png" alt=""></p>
<p>&emsp;&emsp;国内阮一峰翻译如下：</p>
<p><img src="http://image.beekka.com/blog/201105/bg2011050101.png" alt=""></p>

      
    </div>
      <div id="remark"></div>
    <div class="article-info article-info-index">
      
      <a href="/2017/10/25/license/" class="archive-article-date">
  	<time datetime="2017-10-25T06:58:29.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-10-25</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/license/">license</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/个人博客/">个人博客</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-nodeExportExcel" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/06/nodeExportExcel/">node导出Excel表格方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h6 id="如果雷同-纯属巧合"><a href="#如果雷同-纯属巧合" class="headerlink" title="如果雷同,纯属巧合"></a>如果雷同,纯属巧合</h6><p>&emsp;&emsp;解析excel文件,并导出为json格式,可使用<a href="https://github.com/SheetJS/js-xlsx" target="_blank" rel="noopener">SheetJS js-xlsx</a></p>
<p>&emsp;&emsp;解析json语句 【可以来自于前端页面,也可以后台直接调用】可使用可使用<a href="https://github.com/functionscope/Node-Excel-Export" target="_blank" rel="noopener">Excel-Export</a></p>
<p><strong>使用demo:  </strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;node-excel-export&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;node ./index.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;excel-export&quot;: &quot;^0.5.1&quot;,</span><br><span class="line">    &quot;express&quot;: &quot;~4.13.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;express搭建服务器,excel-export到处文件,入口文件为index.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&apos;express&apos;);</span><br><span class="line">var nodeExcel = require(&apos;excel-export&apos;);  //excel到处插件</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.get(&apos;/excel&apos;, function(req, res)&#123;</span><br><span class="line">    //基本excel规则</span><br><span class="line">    var conf = &#123;&#125;;</span><br><span class="line">    conf.stylesXmlFile = &quot;styles.xml&quot;;</span><br><span class="line">    conf.cols = [&#123;</span><br><span class="line">        caption: &apos;编号&apos;,    //行名称</span><br><span class="line">        type:&apos;number&apos;,       //类型</span><br><span class="line">        width: 15,   //宽度</span><br><span class="line">        beforeCellWrite:function(row, cellData)&#123;  //处理数据</span><br><span class="line">            return cellData; //数据大写</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        caption: &apos;姓名&apos;,</span><br><span class="line">        type:&apos;string&apos;,</span><br><span class="line">        width: 20,</span><br><span class="line">        beforeCellWrite:function(row, cellData,eOpt)&#123;  //处理数据</span><br><span class="line"></span><br><span class="line">            if(cellData == &quot;&quot;)&#123;</span><br><span class="line">                return &quot;查无此人&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            return cellData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        caption: &apos;日期&apos;,</span><br><span class="line">        type:&apos;string&apos;,</span><br><span class="line">        width: 25</span><br><span class="line">    &#125;];</span><br><span class="line">    conf.rows = [</span><br><span class="line">        [1, &quot;华晨宇&quot;,&quot;2014-04-15 00:00:00&quot;],</span><br><span class="line">        [2, &quot;&quot;,&quot;2014-04-15 00:00:00&quot;],</span><br><span class="line">        [3, &quot;汪苏泷&quot;,&quot;2014-04-17 00:00:00&quot;],</span><br><span class="line">        [4, &quot;罗一笑&quot;,&quot;2014-04-18 00:00:00&quot;]</span><br><span class="line">    ];</span><br><span class="line">    var result = nodeExcel.execute(conf);</span><br><span class="line">    res.setHeader(&apos;Content-Type&apos;, &apos;application/vnd.openxmlformats&apos;);</span><br><span class="line">    res.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + &quot;userDate.xlsx&quot;); //会保存userDate为文件名的excel文件</span><br><span class="line">    res.end(result, &apos;binary&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8888);</span><br><span class="line">console.log(&apos;Listening on port 8888&apos;);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; conf是配置项,config.cols中定义了表格行的规则,conf.rows是我们模拟的假数据,对应依次打印在excel表中</p>
<p>&emsp;&emsp; conf.cols中有beforeCellWrite方法,可做数据处理</p>
<p>&emsp;&emsp; 我们看到,excel表格的样式规则是一个名叫styles.xml的文件,你可直接复制到自己的项目中</p>
<p>&emsp;&emsp; <a href="https://github.com/Vera0707/huanhuashuixie/blob/master/node-excel-export/styles.xml" target="_blank" rel="noopener">styles.xml文件地址</a></p>
<p>&emsp;&emsp; 服务器端口号为8888.启动服务器后,访问<a href="localhost:8888/excel" target="_blank" rel="noopener">localhost:8888/excel</a></p>
<p>&emsp;&emsp; 打开页面后,会自动下载userDate.excel文件,文件名可根据自己情况做更改</p>
<p>&emsp;&emsp; <a href="https://github.com/Vera0707/huanhuashuixie/tree/master/node-excel-export" target="_blank" rel="noopener">这个demo项目地址</a></p>
<p>&emsp;&emsp; 很简单的小demo,希望对你有用</p>

      
    </div>
      <div id="remark"></div>
    <div class="article-info article-info-index">
      
      <a href="/2017/09/06/nodeExportExcel/" class="archive-article-date">
  	<time datetime="2017-09-06T08:15:59.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-09-06</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/excel表格导出/">excel表格导出</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node/">node</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nodejs/">nodejs</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/个人博客/">个人博客</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-imagesLoad" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/imagesLoad/">判断单、多张图片加载完成</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;在实际的运用中有这样一种场景，某资源加载完成后再执行某个操作，例如在做导出时，后端通过打开模板页生成PDF，并返回下载地址。这时前后端通常需要约定一个flag，用以标识模板准备就绪，可以生成PDF了。</p>
<p>&emsp;&emsp;试想，如果模板中有图片，此时如何判断图片是否加载完成？</p>
<p>&emsp;&emsp;在此之前来了解一下jquery的ready与window.onload的区别，ready只是dom结构加载完毕，便视为加载完成。(此时图片没有加载完毕)，onload是指dom的生成和资源完全加载（比如flash、图片）出来后才执行。接下来回到正题，先从单张图片说起。</p>
<p>&emsp;&emsp;（1）单张图片（图片在文档中）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">'xiu'</span> <span class="attr">src</span>=<span class="string">"http://www.daqianduan.com/wp-content/uploads/2014/11/hs-xiu.jpg"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//jquery</span></span><br><span class="line">    $(<span class="string">'#xiu'</span>).load(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="comment">// 加载完成</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//原生  onload</span></span><br><span class="line">    <span class="keyword">var</span> xiu = <span class="built_in">document</span>.getElementById(<span class="string">'xiu'</span>)</span><br><span class="line">    xiu.onload = xiu.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!<span class="keyword">this</span>.readyState||<span class="keyword">this</span>.readyState==<span class="string">'loaded'</span>||<span class="keyword">this</span>.readyState==<span class="string">'complete'</span>)&#123;</span><br><span class="line">           <span class="comment">// 加载完成</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;注：<br>&emsp;&emsp;1、IE8及以下版本不支持onload事件，但支持onreadystatechange事件；<br>&emsp;&emsp;2、readyState是onreadystatechange事件的一个状态，值为loaded或complete的时候，表示已经加载完毕。<br>&emsp;&emsp;3、以下内容省略兼容</p>
<p>&emsp;&emsp;（2）单张图片（图片动态生成）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiu = <span class="keyword">new</span> Image()</span><br><span class="line"> xiu.src = <span class="string">'http://www.daqianduan.com/wp-content/uploads/2014/11/hs-xiu.jpg'</span></span><br><span class="line"> xiu.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 加载完成</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;（3）单张图片（结合ES6 Promise）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xiu = <span class="keyword">new</span> Image()</span><br><span class="line">    xiu.src = <span class="string">'http://www.daqianduan.com/wp-content/uploads/2014/11/hs-xiu.jpg'</span></span><br><span class="line">    xiu.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="comment">// 加载完成</span></span><br><span class="line">       resolve(xiu)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;).then(<span class="function">(<span class="params">xiu</span>)=&gt;</span>&#123;</span><br><span class="line"> <span class="comment">//code</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;（4）多张图片</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = [],</span><br><span class="line">    flag = <span class="number">0</span>,</span><br><span class="line">    mulitImg = [</span><br><span class="line">    <span class="string">'http://www.daqianduan.com/wp-content/uploads/2017/03/IMG_0119.jpg'</span>,</span><br><span class="line">    <span class="string">'http://www.daqianduan.com/wp-content/uploads/2017/01/1.jpg'</span>,</span><br><span class="line">    <span class="string">'http://www.daqianduan.com/wp-content/uploads/2015/11/jquery.jpg'</span>,</span><br><span class="line">    <span class="string">'http://www.daqianduan.com/wp-content/uploads/2015/10/maid.jpg'</span></span><br><span class="line"> ];</span><br><span class="line"> <span class="keyword">var</span> imgTotal = mulitImg.length;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; imgTotal ; i++)&#123;</span><br><span class="line">    img[i] = <span class="keyword">new</span> Image()</span><br><span class="line">    img[i].src = mulitImg[i]</span><br><span class="line">    img[i].onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="comment">//第i张图片加载完成</span></span><br><span class="line">       flag++</span><br><span class="line">       <span class="keyword">if</span>( flag == imgTotal )&#123;</span><br><span class="line">          <span class="comment">//全部加载完成</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;（5）多张图片（结合ES6 Promise.all()）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mulitImg = [</span><br><span class="line">     <span class="string">'http://www.daqianduan.com/wp-content/uploads/2017/03/IMG_0119.jpg'</span>,</span><br><span class="line">     <span class="string">'http://www.daqianduan.com/wp-content/uploads/2017/01/1.jpg'</span>,</span><br><span class="line">     <span class="string">'http://www.daqianduan.com/wp-content/uploads/2015/11/jquery.jpg'</span>,</span><br><span class="line">     <span class="string">'http://www.daqianduan.com/wp-content/uploads/2015/10/maid.jpg'</span></span><br><span class="line"> ];</span><br><span class="line"> <span class="keyword">let</span> promiseAll = [], img = [], imgTotal = mulitImg.length;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; imgTotal ; i++)&#123;</span><br><span class="line">     promiseAll[i] = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">         img[i] = <span class="keyword">new</span> Image()</span><br><span class="line">         img[i].src = mulitImg[i]</span><br><span class="line">         img[i].onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">              <span class="comment">//第i张加载完成</span></span><br><span class="line">              resolve(img[i])</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">Promise</span>.all(promiseAll).then(<span class="function">(<span class="params">img</span>)=&gt;</span>&#123;</span><br><span class="line">     <span class="comment">//全部加载完成</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
      
    </div>
      <div id="remark"></div>
    <div class="article-info article-info-index">
      
      <a href="/2017/05/23/imagesLoad/" class="archive-article-date">
  	<time datetime="2017-05-23T03:34:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-05-23</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/图片加载/">图片加载</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/图片加载完成事件/">图片加载完成事件</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/个人博客/">个人博客</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-https" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/07/https/">看完就懂的HTTPS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h6 id="译注：本文作者酷壳-陈皓"><a href="#译注：本文作者酷壳-陈皓" class="headerlink" title="译注：本文作者酷壳/陈皓"></a>译注：本文作者酷壳/陈皓</h6><p>&emsp;&emsp;我们先不了聊HTTP，HTTPS，我们先从一个聊天软件说起，我们要实现A能发一个hello消息给B：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/292372-b93c4670333eb8d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>&emsp;&emsp;如果我们要实现这个聊天软件，本文只考虑安全性问题，要实现</p>
<blockquote>
<p>A发给B的hello消息包，即使被中间人拦截到了，也无法得知消息的内容</p>
</blockquote>
<p><abbr title="" style="color:#b01942;font-weight:bold;background:#fff">如何做到真正的安全？</abbr></p>
<p>&emsp;&emsp;这个问题，很多人马上就想到了各种加密算法，什么对称加密、非对称加密、DES、RSA、XX、噼里啪啦~<br>&emsp;&emsp;而我想说，加密算法只是解决方案，我们首先要做的是理解我们的问题域——什么是安全？<br>&emsp;&emsp;我个人的理解是：</p>
<blockquote>
<p>A与B通信的内容，有且只有A和B有能力看到通信的真正内容</p>
</blockquote>
<p>&emsp;&emsp;好，问题域已经定义好了（现实中当然不止这一种定义）。对于解决方案，很容易就想到了对消息进行加密。<br>&emsp;&emsp;题外话，但是只有这一种方法吗？我看未必，说不定在将来会出现一种物质打破当前世界的通信假设，实现真正意义上的保密。<br>&emsp;&emsp;对于A与B这样的简单通信模型，我们很容易做出选择：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/292372-9d943956300560f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>&emsp;&emsp;这就是对称加密算法，其中图中的密钥S同时扮演加密和解密的角色。具体细节不是本文范畴。<br>&emsp;&emsp;只要这个密钥S不公开给第三者，同时密钥S足够安全，我们就解决了我们一开始所定问题域了。因为世界上有且只有A与B知道如何加密和解密他们之间的消息。<br>&emsp;&emsp;但是，在WWW环境下，我们的Web服务器的通信模型没有这么简单：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/292372-528782117a69a5dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>&emsp;&emsp;如果服务器端对所有的客户端通信都使用同样的对称加密算法，无异于没有加密。那怎么办呢？即能使用对称加密算法，又不公开密钥？请读者思考21秒钟。</p>
<p>&emsp;&emsp;答案是：Web服务器与每个客户端使用不同的对称加密算法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/292372-d38dbcf3633a1cc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><abbr title="" style="color:#b01942;font-weight:bold;background:#fff">如何确定对称加密算法</abbr></p>
<p>&emsp;&emsp;慢着，另一个问题来了，我们的服务器端怎么告诉客户端该使用哪种对称加密算法？<br>&emsp;&emsp;当然是通过协商。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/292372-88ce3bd16ac6006d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>&emsp;&emsp;但是，你协商的过程是没有加密的，还是会被中间人拦截。那我们再对这个协商过程进行对称加密就好了，那你对协商过程加密的加密还是没有加密，怎么办？再加密不就好了……好吧，进行鸡生蛋蛋生鸡的问题了。</p>
<p><abbr title="" style="color:#b01942;font-weight:bold;background:#fff">如何对协商过程进行加密</abbr></p>
<p>&emsp;&emsp;新问题来了，如何对协商过程进行加密？密码学领域中，有一种称为“非对称加密”的加密算法，特点是私钥加密后的密文，只要是公钥，都可以解密，但是公钥加密后的密文，只有私钥可以解密。私钥只有一个人有，而公钥可以发给所有的人。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/292372-ae678fa7d569dac9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>&emsp;&emsp;虽然服务器端向A、B……的方向还是不安全的，但是至少A、B向服务器端方向是安全的。<br>&emsp;&emsp;好了，如何协商加密算法的问题，我们解决了：使用非对称加密算法进行对称加密算法协商过程。<br>&emsp;&emsp;这下，你明白为什么HTTPS同时需要对称加密算法和非对称加密算法了吧？</p>
<p><abbr title="" style="color:#b01942;font-weight:bold;background:#fff">协商什么加密算法</abbr></p>
<p>&emsp;&emsp;要达到Web服务器针对每个客户端使用不同的对称加密算法，同时，我们也不能让第三者知道这个对称加密算法是什么，怎么办？<br>&emsp;&emsp;使用随机数，就是使用随机数来生成对称加密算法。这样就可以做到服务器和客户端每次交互都是新的加密算法、只有在交互的那一该才确定加密算法。<br>&emsp;&emsp;这下，你明白为什么HTTPS协议握手阶段会有这么多的随机数了吧。</p>
<p><abbr title="" style="color:#b01942;font-weight:bold;background:#fff">如何得到公钥？</abbr></p>
<p>&emsp;&emsp;细心的人可能已经注意到了如果使用非对称加密算法，我们的客户端A，B需要一开始就持有公钥，要不没法开展加密行为啊。<br>&emsp;&emsp;这下，我们又遇到新问题了，如何让A、B客户端安全地得到公钥？<br>&emsp;&emsp;我能想到的方案只有这些：</p>
<ul>
<li>方案1. 服务器端将公钥发送给每一个客户端</li>
<li>方案2. 服务器端将公钥放到一个远程服务器，客户端可以请求得到</li>
</ul>
<p>&emsp;&emsp;我们选择方案1，因为方案2又多了一次请求，还要另外处理公钥的放置问题。<br>&emsp;&emsp;公钥被调包了怎么办？又是一个鸡生蛋蛋生鸡问题？<br>&emsp;&emsp;但是方案1有个问题：如果服务器端发送公钥给客户端时，被中间人调包了，怎么办？</p>
<p>&emsp;&emsp;我画了张图方便理解：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/292372-8f0d8228af2f6480.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>&emsp;&emsp;显然，让每个客户端的每个浏览器默认保存所有网站的公钥是不现实的。</p>
<p><abbr title="" style="color:#b01942;font-weight:bold;background:#fff">使用第三方机构的公钥解决鸡生蛋蛋生鸡问题</abbr></p>
<p>&emsp;&emsp;公钥被调包的问题出现，是因为我们的客户端无法分辨返回公钥的人到底是中间人，还是真的服务器。这其实就是密码学中提的身份验证问题。<br>&emsp;&emsp;如果让你来解决，你怎么解决？如果你了解过HTTPS，会知道使用数字证书来解决。但是你想过证书的本质是什么么？请放下你对HTTPS已有的知识，自己尝试找到解决方案。<br>&emsp;&emsp;我是这样解决的。既然服务器需要将公钥传给客户端，这个过程本身是不安全，那么我们为什么不对这个过程本身再加密一次？可是，你是使用对称加密，还是非对称加密？这下好了，我感觉又进了鸡生蛋蛋生鸡问题了。<br>&emsp;&emsp;问题的难点是如果我们选择直接将公钥传递给客户端的方案，我们始终无法解决公钥传递被中间人调包的问题。<br>&emsp;&emsp;所以，我们不能直接将服务器的公钥传递给客户端，而是第三方机构使用它的私钥对我们的公钥进行加密后，再传给客户端。客户端再使用第三方机构的公钥进行解密。<br>&emsp;&emsp;下图就是我们设计的第一版“数字证书”，证书中只有服务器交给第三方机构的公钥，而且这个公钥被第三方机构的私钥加密了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/292372-f3dd4b7370df950e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>&emsp;&emsp;如果能解密，就说明这个公钥没有被中间人调包。因为如果中间人使用自己的私钥加密后的东西传给客户端，客户端是无法使用第三方的公钥进行解密的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/292372-3b7c21b3525c0e64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>&emsp;&emsp;话到此，我以为解决问题了。但是现实中HTTPS，还有一个数字签名的概念，我没法理解它的设计理由。<br>&emsp;&emsp;原来，我漏掉了一个场景：第三方机构不可能只给你一家公司制作证书，它也可能会给中间人这样有坏心思的公司发放证书。这样的，中间人就有机会对你的证书进行调包，客户端在这种情况下是无法分辨出是接收的是你的证书，还是中间人的。因为不论中间人，还是你的证书，都能使用第三方机构的公钥进行解密。像下面这样：<br>&emsp;&emsp;第三方机构向多家公司颁发证书的情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/292372-66e00dc26cea3112.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>&emsp;&emsp;客户端能解密同一家第三机构颁发的所有证书：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/292372-5bf2c898914e749f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>&emsp;&emsp;最终导致其它持有同一家第三方机构证书的中间人可以进行调包：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/292372-b2bd3805bc25fd2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><abbr title="" style="color:#b01942;font-weight:bold;background:#fff">数字签名，解决同一机构颁发的不同证书被篡改问题</abbr></p>
<p>&emsp;&emsp;要解决这个问题，我们首先要想清楚一个问题，辨别同一机构下不同证书的这个职责，我们应该放在哪？<br>&emsp;&emsp;只能放到客户端了。意思是，客户端在拿到证书后，自己就有能力分辨证书是否被篡改了。如何才能有这个能力呢？<br>&emsp;&emsp;我们从现实中找灵感。比如你是HR，你手上拿到候选人的学历证书，证书上写了持证人，颁发机构，颁发时间等等，同时证书上，还写有一个最重要的：证书编号！我们怎么鉴别这张证书是的真伪呢？只要拿着这个证书编号上相关机构去查，如果证书上的持证人与现实的这个候选人一致，同时证书编号也能对应上，那么就说明这个证书是真实的。<br>&emsp;&emsp;我们的客户端能不能采用这个机制呢？像这样：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/292372-ac2b0d452a4e8b05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>&emsp;&emsp;可是，这个“第三方机构”到底是在哪呢？是一个远端服务？不可能吧？如果是个远端服务，整个交互都会慢了。所以，这个第三方机构的验证功能只能放在客户端的本地了。</p>
<p><abbr title="" style="color:#b01942;font-weight:bold;background:#fff">客户端本地怎么验证证书呢？</abbr></p>
<p>&emsp;&emsp;客户端本地怎么验证证书呢？答案是证书本身就已经告诉客户端怎么验证证书的真伪。<br>&emsp;&emsp;也就是证书上写着如何根据证书的内容生成证书编号。客户端拿到证书后根据证书上的方法自己生成一个证书编号，如果生成的证书编号与证书上的证书编号相同，那么说明这个证书是真实的。<br>&emsp;&emsp;同时，为避免证书编号本身又被调包，所以使用第三方的私钥进行加密。<br>&emsp;&emsp;这地方有些抽象，我们来个图帮助理解：<br>&emsp;&emsp;证书的制作如图所示。证书中的“编号生成方法MD5”就是告诉客户端：你使用MD5对证书的内容求值就可以得到一个证书编号。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/292372-60fd73c3f79e8641.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>&emsp;&emsp;当客户端拿到证书后，开始对证书中的内容进行验证，如果客户端计算出来的证书编号与证书中的证书编号相同，则验证通过：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/292372-4dbf41053fb6fb25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>&emsp;&emsp;但是第三方机构的公钥怎么跑到了客户端的机器中呢？世界上这么多机器。<br>&emsp;&emsp;其实呢，现实中，浏览器和操作系统都会维护一个权威的第三方机构列表（包括它们的公钥）。因为客户端接收到的证书中会写有颁发机构，客户端就根据这个颁发机构的值在本地找相应的公钥。</p>
<blockquote>
<p>题外话：如果浏览器和操作系统这道防线被破了，就没办法。想想当年自己装过的非常规XP系统，都害怕。</p>
</blockquote>
<p>&emsp;&emsp;说到这里，想必大家已经知道上文所说的，证书就是HTTPS中数字证书，证书编号就是数字签名，而第三方机构就是指数字证书签发机构（CA）。</p>
<p><abbr title="" style="color:#b01942;font-weight:bold;background:#fff">CA如何颁发数字证书给服务器端的？</abbr></p>
<p>&emsp;&emsp;当我听到这个问题时，我误以为，我们的SERVER需要发网络请求到CA部门的服务器来拿这个证书。😭 到底是我理解能力问题，还是。。<br>&emsp;&emsp;其实，问题应该是CA如何颁发给我们的网站管理员，而我们的管理员又如何将这个数字证书放到我们的服务器上。</p>
<p>&emsp;&emsp;我们如何向CA申请呢？每个CA机构都大同小异，我在网上找了一个：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/292372-6eb448d41e6bc2fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>&emsp;&emsp;拿到证书后，我们就可以将证书配置到自己的服务器上了。那么如何配置？这是具体细节了，留给大家google了。</p>
<p><abbr title="" style="color:#b01942;font-weight:bold;background:#fff">也许我们需要整理一下思路</abbr></p>
<p>&emsp;&emsp;我们通过推算的方式尝试还原HTTPS的设计过程。这样，我们也就明白了为什么HTTPS比HTTP多那么多次的交互，为什么HTTPS的性能会差，以及找到HTTPS的性能优化点。<br>&emsp;&emsp;而上面一大堆工作都是为了让客户端与服务器端安全地协商出一个对称加密算法。这就是HTTPS中的SSL/TLS协议主要干的活。剩下的就是通信时双方使用这个对称加密算法进行加密解密。<br>&emsp;&emsp;以下是一张HTTPS协议的真实交互图（从网上copy的，忘了从哪了，如果侵权麻烦告知）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/292372-323411d0bb2d7232.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><abbr title="" style="color:#b01942;font-weight:bold;background:#fff">能不能用一句话总结HTTPS？</abbr></p>
<p>&emsp;&emsp;答案是不能，因为HTTPS本身实在太复杂。但是我还是尝试使用一段话来总结HTTPS:<br>&emsp;&emsp;HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。</p>

      
    </div>
      <div id="remark"></div>
    <div class="article-info article-info-index">
      
      <a href="/2017/03/07/https/" class="archive-article-date">
  	<time datetime="2017-03-07T04:03:49.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-03-07</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/理解https/">理解https</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-price-tags"></i>
	<a class="article-category-link" href="/categories/个人博客/">个人博客</a>
	</div>


      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2019 谢雨轩
    	</div>
      	<div class="footer-right">虽然生的丑 毕竟想的美</div>
    </div>
  </div>
</footer>

    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/FHS/" style="font-size: 11.67px;">FHS</a> <a href="/tags/css-hack/" style="font-size: 10px;">css hack</a> <a href="/tags/excel表格导出/" style="font-size: 10px;">excel表格导出</a> <a href="/tags/jquery/" style="font-size: 10px;">jquery</a> <a href="/tags/jquery源码/" style="font-size: 10px;">jquery源码</a> <a href="/tags/jquery源码教程/" style="font-size: 10px;">jquery源码教程</a> <a href="/tags/js原型/" style="font-size: 10px;">js原型</a> <a href="/tags/license/" style="font-size: 10px;">license</a> <a href="/tags/linux/" style="font-size: 11.67px;">linux</a> <a href="/tags/linux操作/" style="font-size: 10px;">linux操作</a> <a href="/tags/linux文件/" style="font-size: 10px;">linux文件</a> <a href="/tags/linux环境变量/" style="font-size: 10px;">linux环境变量</a> <a href="/tags/node/" style="font-size: 10px;">node</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/react-redux/" style="font-size: 10px;">react-redux</a> <a href="/tags/redux/" style="font-size: 10px;">redux</a> <a href="/tags/rich-text/" style="font-size: 10px;">rich-text</a> <a href="/tags/underscore/" style="font-size: 10px;">underscore</a> <a href="/tags/underscore源码/" style="font-size: 10px;">underscore源码</a> <a href="/tags/v-model/" style="font-size: 10px;">v-model</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/vim命令/" style="font-size: 10px;">vim命令</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/webpack/" style="font-size: 16.67px;">webpack</a> <a href="/tags/webpack-4-0/" style="font-size: 15px;">webpack 4.0</a> <a href="/tags/webpack优化/" style="font-size: 10px;">webpack优化</a> <a href="/tags/webpack教程/" style="font-size: 15px;">webpack教程</a> <a href="/tags/依赖倒置原则/" style="font-size: 11.67px;">依赖倒置原则</a> <a href="/tags/全栈/" style="font-size: 10px;">全栈</a> <a href="/tags/前端/" style="font-size: 20px;">前端</a> <a href="/tags/前端学习/" style="font-size: 10px;">前端学习</a> <a href="/tags/前端工程师/" style="font-size: 10px;">前端工程师</a> <a href="/tags/前端常用网站/" style="font-size: 10px;">前端常用网站</a> <a href="/tags/前端打包工具/" style="font-size: 10px;">前端打包工具</a> <a href="/tags/前端设计模式/" style="font-size: 18.33px;">前端设计模式</a> <a href="/tags/单一职责原则/" style="font-size: 10px;">单一职责原则</a> <a href="/tags/原创/" style="font-size: 13.33px;">原创</a> <a href="/tags/双向绑定/" style="font-size: 10px;">双向绑定</a> <a href="/tags/图片加载/" style="font-size: 10px;">图片加载</a> <a href="/tags/图片加载完成事件/" style="font-size: 10px;">图片加载完成事件</a> <a href="/tags/开闭原则/" style="font-size: 10px;">开闭原则</a> <a href="/tags/微信小程序/" style="font-size: 10px;">微信小程序</a> <a href="/tags/技术发展/" style="font-size: 10px;">技术发展</a> <a href="/tags/接口隔离原则/" style="font-size: 10px;">接口隔离原则</a> <a href="/tags/正则/" style="font-size: 10px;">正则</a> <a href="/tags/源码/" style="font-size: 11.67px;">源码</a> <a href="/tags/滚动信息条间歇性滚动/" style="font-size: 10px;">滚动信息条间歇性滚动</a> <a href="/tags/理解https/" style="font-size: 10px;">理解https</a> <a href="/tags/迪米特法则/" style="font-size: 10px;">迪米特法则</a> <a href="/tags/里氏替换原则/" style="font-size: 10px;">里氏替换原则</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/Vera0707/huanhuashuixie/tree/master/framework">流行框架练习</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">一枚深水前端&lt;br/&gt;&lt;br/&gt;大神带带我&lt;br/&gt;小白我要升级打倒小怪兽</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <!--<script>-->
      <!--var WIDTH = window.innerWidth, HEIGHT = window.innerHeight, POINT = 35;-->

      <!--var canvas = document.getElementById('body-wrap');-->
      <!--canvas.width = WIDTH,-->
          <!--canvas.height = HEIGHT;-->
      <!--var context = canvas.getContext('2d');-->
      <!--context.strokeStyle = 'rgba(0,0,0,0.2)',-->
          <!--context.strokeWidth = 1,-->
          <!--context.fillStyle = 'rgba(0,0,0,0.1)';-->
      <!--var circleArr = [];-->

      <!--//线条：开始xy坐标，结束xy坐标，线条透明度-->
      <!--function Line (x, y, _x, _y, o) {-->
          <!--this.beginX = x,-->
              <!--this.beginY = y,-->
              <!--this.closeX = _x,-->
              <!--this.closeY = _y,-->
              <!--this.o = o;-->
      <!--}-->
      <!--//点：圆心xy坐标，半径，每帧移动xy的距离-->
      <!--function Circle (x, y, r, moveX, moveY) {-->
          <!--this.x = x,-->
              <!--this.y = y,-->
              <!--this.r = r,-->
              <!--this.moveX = moveX,-->
              <!--this.moveY = moveY;-->
      <!--}-->
      <!--//生成max和min之间的随机数-->
      <!--function num (max, _min) {-->
          <!--var min = arguments[1] || 0;-->
          <!--return Math.floor(Math.random()*(max-min+1)+min);-->
      <!--}-->
      <!--// 绘制原点-->
      <!--function drawCricle (cxt, x, y, r, moveX, moveY) {-->
          <!--var circle = new Circle(x, y, r, moveX, moveY)-->
          <!--cxt.beginPath()-->
          <!--cxt.arc(circle.x, circle.y, circle.r, 0, 2*Math.PI)-->
          <!--cxt.closePath()-->
          <!--cxt.fill();-->
          <!--return circle;-->
      <!--}-->
      <!--//绘制线条-->
      <!--function drawLine (cxt, x, y, _x, _y, o) {-->
          <!--var line = new Line(x, y, _x, _y, o)-->
          <!--cxt.beginPath()-->
          <!--cxt.strokeStyle = 'rgba(0,0,0,'+ o +')'-->
          <!--cxt.moveTo(line.beginX, line.beginY)-->
          <!--cxt.lineTo(line.closeX, line.closeY)-->
          <!--cxt.closePath()-->
          <!--cxt.stroke();-->

      <!--}-->
      <!--//每帧绘制-->
      <!--function draw () {-->
          <!--context.clearRect(0,0,canvas.width, canvas.height);-->
          <!--for (var i = 0; i < POINT; i++) {-->
              <!--drawCricle(context, circleArr[i].x, circleArr[i].y, circleArr[i].r);-->
          <!--}-->
          <!--for (var i = 0; i < POINT; i++) {-->
              <!--for (var j = 0; j < POINT; j++) {-->
                  <!--if (i + j < POINT) {-->
                      <!--var A = Math.abs(circleArr[i+j].x - circleArr[i].x),-->
                          <!--B = Math.abs(circleArr[i+j].y - circleArr[i].y);-->
                      <!--var lineLength = Math.sqrt(A*A + B*B);-->
                      <!--var C = 1/lineLength*7-0.009;-->
                      <!--var lineOpacity = C > 0.03 ? 0.03 : C;-->
                      <!--if (lineOpacity > 0) {-->
                          <!--drawLine(context, circleArr[i].x, circleArr[i].y, circleArr[i+j].x, circleArr[i+j].y, lineOpacity);-->
                      <!--}-->
                  <!--}-->
              <!--}-->
          <!--}-->
      <!--}-->
      <!--//初始化生成原点-->
      <!--function init () {-->
          <!--circleArr = [];-->
          <!--for (var i = 0; i < POINT; i++) {-->
              <!--circleArr.push(drawCricle(context, num(WIDTH), num(HEIGHT), num(15, 2), num(10, -10)/40, num(10, -10)/40));-->
          <!--}-->
          <!--draw();-->
      <!--}-->
      <!--//调用执行-->
      <!--window.onload = function () {-->
          <!--init();-->
          <!--setInterval(function () {-->
              <!--for (var i = 0; i < POINT; i++) {-->
                  <!--var cir = circleArr[i];-->
                  <!--cir.x += cir.moveX;-->
                  <!--cir.y += cir.moveY;-->
                  <!--if (cir.x > WIDTH) cir.x = 0;-->
                  <!--else if (cir.x < 0) cir.x = WIDTH;-->
                  <!--if (cir.y > HEIGHT) cir.y = 0;-->
                  <!--else if (cir.y < 0) cir.y = HEIGHT;-->
              <!--}-->
              <!--draw();-->
          <!--}, 10);-->
      <!--}-->
  <!--</script>-->
  <!--<script>-->
      <!--var gitment = new Gitment({-->
          <!--id: '', // 可选。默认为 location.href-->
          <!--owner: 'vera0707',-->
          <!--repo: 'https://github.com/vera0707/vera0707.github.io',-->
          <!--labels: "gitment-introduction",-->
          <!--oauth: {-->
              <!--client_id: '412dc716eeeb8fa2983f',-->
              <!--client_secret: 'e350354961bdca67937a21eed747e23ba1e6f86e'-->
          <!--}-->
      <!--})-->
      <!--gitment.render('remark')-->
  <!--</script>-->
</body>
</html>